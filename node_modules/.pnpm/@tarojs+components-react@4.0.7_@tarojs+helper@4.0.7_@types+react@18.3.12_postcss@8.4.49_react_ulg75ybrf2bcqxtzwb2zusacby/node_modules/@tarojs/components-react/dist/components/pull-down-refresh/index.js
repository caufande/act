import { __rest } from 'tslib';
import './style/index.css.js';
import Taro from '@tarojs/taro';
import classNames from 'classnames';
import React__default from 'react';
import { createForwardRefComponent } from '../../utils/index.js';
import { jsx, jsxs } from 'react/jsx-runtime';

function setTransform(nodeStyle, value) {
  nodeStyle.transform = value;
  nodeStyle.webkitTransform = value;
  nodeStyle.MozTransform = value;
}
const isWebView = typeof navigator !== 'undefined' && /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
var PullDownState;
(function (PullDownState) {
  PullDownState["activate"] = "activate";
  PullDownState["deactivate"] = "deactivate";
  PullDownState["release"] = "release";
  PullDownState["finish"] = "finish";
})(PullDownState || (PullDownState = {}));
var INDICATOR;
(function (INDICATOR) {
  INDICATOR["activate"] = "release";
  INDICATOR["deactivate"] = "pull";
  INDICATOR["release"] = "loading";
  INDICATOR["finish"] = "finish";
})(INDICATOR || (INDICATOR = {}));
let supportsPassive = false;
try {
  const opts = Object.defineProperty({}, 'passive', {
    get() {
      supportsPassive = true;
    }
  });
  window.addEventListener('cancel', () => ({}), opts);
} catch (e) {} // eslint-disable-line no-empty
const willPreventDefault = supportsPassive ? {
  passive: false
} : false;
class PullDownRefresh extends React__default.Component {
  constructor() {
    super(...arguments);
    // https://github.com/yiminghe/zscroller/blob/2d97973287135745818a0537712235a39a6a62a1/src/Scroller.js#L355
    // currSt: `activate` / `deactivate` / `release` / `finish`
    this.state = {
      currSt: PullDownState.deactivate,
      dragOnEdge: false
    };
    this._ScreenY = 0;
    this._startScreenY = 0;
    this._lastScreenY = 0;
    this._isMounted = false;
    this.listeners = [];
    this.triggerPullDownRefresh = flag => {
      // 在初始化时、用代码 自动 触发 pullDownRefresh
      // 添加this._isMounted的判断，否则组建一实例化，currSt就会是finish
      if (!this.state.dragOnEdge && this._isMounted) {
        if (flag) {
          this._lastScreenY = this.props.distanceToRefresh + 1;
          // change dom need after setState
          this.setState({
            currSt: PullDownState.release
          }, () => this.setContentStyle(this._lastScreenY));
        } else {
          this.setState({
            currSt: PullDownState.finish
          }, () => this.reset());
        }
      }
    };
    this.init = () => {
      const ele = this.scrollContainer;
      this._to = {
        touchstart: this.onTouchStart.bind(this, ele),
        touchmove: this.onTouchMove.bind(this, ele),
        touchend: this.onTouchEnd.bind(this, ele),
        touchcancel: this.onTouchEnd.bind(this, ele)
      };
      Object.keys(this._to).forEach(key => {
        ele.addEventListener(key, this._to[key], willPreventDefault);
      });
    };
    this.destroy = () => {
      if (!this._to) return;
      const ele = this.scrollContainer;
      Object.keys(this._to).forEach(key => {
        ele.removeEventListener(key, this._to[key]);
      });
    };
    this.onTouchStart = (_, e) => {
      this._ScreenY = this._startScreenY = e.touches[0].screenY;
      // 一开始 refreshing 为 true 时 this._lastScreenY 有值
      this._lastScreenY = this._lastScreenY || 0;
    };
    this.isEdge = ele => {
      const container = this.scrollContainer;
      if (container && container === document.body) {
        // In chrome61 `document.body.scrollTop` is invalid
        const scrollNode = document.scrollingElement ? document.scrollingElement : document.body;
        return scrollNode.scrollTop <= 0;
      }
      return ele.scrollTop <= 0;
    };
    this.damping = dy => {
      if (Math.abs(this._lastScreenY) > this.props.damping) {
        return 0;
      }
      const ratio = Math.abs(this._ScreenY - this._startScreenY) / window.screen.height;
      dy *= (1 - ratio) * 0.6;
      return dy;
    };
    this.onTouchMove = (ele, e) => {
      // 使用 pageY 对比有问题
      const _screenY = e.touches[0].screenY;
      // 拖动方向不符合的不处理
      if (this._startScreenY > _screenY) {
        return;
      }
      if (this.isEdge(ele)) {
        if (!this.state.dragOnEdge) {
          // 当用户开始往上滑的时候isEdge还是false的话，会导致this._ScreenY不是想要的，只有当isEdge为true时，再上滑，才有意义
          // 下面这行代码解决了上面这个问题
          this._ScreenY = this._startScreenY = e.touches[0].screenY;
          this.setState({
            dragOnEdge: true
          });
        }
        if (e.cancelable) {
          e.preventDefault();
        }
        // add stopPropagation with fastclick will trigger content onClick event. why?
        // ref https://github.com/ant-design/ant-design-mobile/issues/2141
        // e.stopPropagation();
        const _diff = Math.round(_screenY - this._ScreenY);
        this._ScreenY = _screenY;
        this._lastScreenY += this.damping(_diff);
        this.setContentStyle(this._lastScreenY);
        if (Math.abs(this._lastScreenY) < this.props.distanceToRefresh) {
          if (this.state.currSt !== PullDownState.deactivate) {
            // console.log('back to the distance');
            this.setState({
              currSt: PullDownState.deactivate
            });
          }
        } else {
          if (this.state.currSt === PullDownState.deactivate) {
            // console.log('reach to the distance');
            this.setState({
              currSt: PullDownState.activate
            });
          }
        }
        // https://github.com/ant-design/ant-design-mobile/issues/573#issuecomment-339560829
        // iOS UIWebView issue, It seems no problem in WKWebView
        if (isWebView && e.changedTouches[0].clientY < 0) {
          this.onTouchEnd();
        }
      }
    };
    this.onTouchEnd = () => {
      var _a, _b;
      if (this.state.dragOnEdge) {
        this.setState({
          dragOnEdge: false
        });
      }
      if (this.state.currSt === PullDownState.activate) {
        this.setState({
          currSt: PullDownState.release
        });
        (_b = (_a = this.props).onRefresh) === null || _b === void 0 ? void 0 : _b.call(_a);
        this._lastScreenY = this.props.distanceToRefresh + 1;
        this.setContentStyle(this._lastScreenY);
      } else if (this.state.currSt === 'release') {
        this._lastScreenY = this.props.distanceToRefresh + 1;
        this.setContentStyle(this._lastScreenY);
      } else {
        this.reset();
      }
    };
    this.reset = () => {
      this._lastScreenY = 0;
      this.setContentStyle(0);
    };
    this.setContentStyle = ty => {
      // TODO: Why sometimes do not have `this.contentRef` ?
      if (this.contentRef) {
        // translate3d 不清理 会影响内部元素定位
        if (ty) {
          setTransform(this.contentRef.style, `translate3d(0px,${ty}px,0)`);
        } else {
          setTransform(this.contentRef.style, '');
        }
      }
    };
  }
  get scrollContainer() {
    var _a, _b;
    return ((_a = this.contentRef) === null || _a === void 0 ? void 0 : _a.parentElement) || ((_b = this.contentRef) === null || _b === void 0 ? void 0 : _b.closest('.taro_page_stationed')) || document.querySelector('.taro_page_stationed') || document.querySelector('.taro_page') || document.querySelector('.taro_router') || document.querySelector('.taro-tabbar__panel') || document.body;
  }
  componentDidMount() {
    this.init();
    this._isMounted = true;
    this.listeners = [['__taroStartPullDownRefresh', _ref => {
      let {
        successHandler,
        errorHandler
      } = _ref;
      try {
        this.triggerPullDownRefresh(true);
        successHandler({
          errMsg: 'startPullDownRefresh: ok'
        });
      } catch (e) {
        errorHandler({
          errMsg: 'startPullDownRefresh: fail'
        });
      }
    }], ['__taroStopPullDownRefresh', _ref2 => {
      let {
        successHandler,
        errorHandler
      } = _ref2;
      try {
        this.triggerPullDownRefresh(false);
        successHandler({
          errMsg: 'stopPullDownRefresh: ok'
        });
      } catch (e) {
        errorHandler({
          errMsg: 'stopPullDownRefresh: fail'
        });
      }
    }]];
    this.listeners.forEach(_ref3 => {
      let [evtName, callback] = _ref3;
      Taro.eventCenter.on(evtName, callback);
    });
  }
  componentWillUnmount() {
    this.destroy();
    this.listeners.forEach(_ref4 => {
      let [evtName, callback] = _ref4;
      Taro.eventCenter.off(evtName, callback);
    });
  }
  componentDidUpdate(_, prevState) {
    var _a, _b, _c, _d;
    if (prevState.currSt !== this.state.currSt) {
      const pageEl = this.scrollContainer;
      switch (this.state.currSt) {
        case PullDownState.release:
          (_b = (_a = pageEl === null || pageEl === void 0 ? void 0 : pageEl.__page) === null || _a === void 0 ? void 0 : _a.onPullDownRefresh) === null || _b === void 0 ? void 0 : _b.call(_a);
          break;
        case PullDownState.deactivate:
          (_d = (_c = pageEl === null || pageEl === void 0 ? void 0 : pageEl.__page) === null || _c === void 0 ? void 0 : _c.onPullIntercept) === null || _d === void 0 ? void 0 : _d.call(_c);
      }
    }
  }
  render() {
    const props = Object.assign({}, this.props);
    delete props.damping;
    delete props.indicator;
    delete props.distanceToRefresh;
    delete props.onRefresh;
    const {
        className,
        prefixCls,
        children,
        forwardedRef
      } = props,
      restProps = __rest(props, ["className", "prefixCls", "children", "forwardedRef"]);
    const renderRefresh = cls => {
      const {
        currSt,
        dragOnEdge
      } = this.state;
      const cla = classNames(cls, !dragOnEdge && `${prefixCls}-transition`);
      const showIndicator = currSt === 'activate' || currSt === 'release';
      return /*#__PURE__*/jsx("div", {
        className: `${prefixCls}-content-wrapper`,
        children: /*#__PURE__*/jsxs("div", {
          className: cla,
          ref: el => {
            this.contentRef = el;
          },
          children: [showIndicator && /*#__PURE__*/jsxs("div", {
            className: `${prefixCls}-indicator`,
            children: [/*#__PURE__*/jsx("div", {}), /*#__PURE__*/jsx("div", {}), /*#__PURE__*/jsx("div", {})]
          }), children]
        })
      });
    };
    if (this.scrollContainer) {
      return renderRefresh(`${prefixCls}-content ${prefixCls}-down`);
    }
    return /*#__PURE__*/jsx("pull-down-refresh", {
      ref: el => {
        if (forwardedRef) {
          forwardedRef.current = el;
        }
        this.containerRef = el;
      },
      className: classNames(className, prefixCls, `${prefixCls}-down`),
      ...restProps,
      children: renderRefresh(`${prefixCls}-content`)
    });
  }
}
PullDownRefresh.defaultProps = {
  prefixCls: 'rmc-pull-to-refresh',
  distanceToRefresh: 50,
  damping: 100,
  indicator: INDICATOR
};
var index = createForwardRefComponent(PullDownRefresh);

export { index as default };
//# sourceMappingURL=index.js.map
