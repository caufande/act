import { __rest, __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import 'swiper/swiper-bundle.css';
import './style/index.css.js';
import classNames from 'classnames';
import React__default from 'react';
import Swipers from 'swiper/bundle';
import { debounce, createForwardRefComponent } from '../../utils/index.js';
import { jsx, jsxs } from 'react/jsx-runtime';

var _SwiperInner_source, _SwiperInner_swiperResetting, _SwiperInner_lastSwiperActiveIndex, _SwiperInner_domChangeByOutSide;
let INSTANCE_ID = 0;
const ONE_ADDITIONAL_SLIDES_THRESHOLD = 5;
const TWO_ADDITIONAL_SLIDES_THRESHOLD = 7;
const createEvent = type => {
  let e;
  try {
    e = new TouchEvent(type);
  } catch (err) {
    e = document.createEvent('Event');
    e.initEvent(type, true, true);
  }
  return e;
};
class SwiperItemInner extends React__default.Component {
  render() {
    const _a = this.props,
      {
        className,
        style,
        itemId,
        children,
        forwardedRef
      } = _a,
      restProps = __rest(_a, ["className", "style", "itemId", "children", "forwardedRef"]);
    const cls = classNames('swiper-slide', className);
    return /*#__PURE__*/jsx("div", {
      ref: e => {
        if (e && forwardedRef) {
          forwardedRef.current = e;
        }
      },
      className: cls,
      style: style,
      "item-id": itemId,
      ...restProps,
      children: children
    });
  }
}
class SwiperInner extends React__default.Component {
  constructor(props) {
    var _this;
    super(props);
    _this = this;
    this._id = 1 + INSTANCE_ID++;
    _SwiperInner_source.set(this, 'autoplay');
    _SwiperInner_swiperResetting.set(this, false);
    _SwiperInner_lastSwiperActiveIndex.set(this, 0
    // dom 变化是否由外部引起，因为 swiper 的循环模式也会引起 dom 的变化。如果不是由外部引起的 dom 变化，就不需要重新初始化 swiper
    );
    // dom 变化是否由外部引起，因为 swiper 的循环模式也会引起 dom 的变化。如果不是由外部引起的 dom 变化，就不需要重新初始化 swiper
    _SwiperInner_domChangeByOutSide.set(this, false);
    this.handleInit = function () {
      let reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const {
        autoplay = false,
        circular = true,
        current = 0,
        displayMultipleItems = 1,
        duration = 500,
        interval = 5000,
        currentItemId,
        effectsProps = {},
        vertical
      } = _this.props;
      let initialSlide = parseInt(String(current), 10);
      if (reset) {
        initialSlide = __classPrivateFieldGet(_this, _SwiperInner_lastSwiperActiveIndex, "f");
      } else {
        if (currentItemId) {
          let itemIdIndex = 0;
          _this.getSlidersList().forEach((swiperItem, index) => {
            // @ts-ignore
            if (swiperItem.itemId && swiperItem.itemId === currentItemId) {
              itemIdIndex = index;
            }
          });
          initialSlide = itemIdIndex;
        }
      }
      const loopAdditionalSlides = _this.getLoopAdditionalSlides();
      const centeredSlides = displayMultipleItems === 1 && _this.getNeedFixLoop();
      const slidesPerView = parseFloat(String(displayMultipleItems)) === 1 ? 'auto' : displayMultipleItems;
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const that = _this;
      const opt = Object.assign(Object.assign({
        // 指示器
        pagination: {
          el: `.taro-swiper-${_this._id} > .swiper-container > .swiper-pagination`
        },
        direction: vertical ? 'vertical' : 'horizontal',
        loop: circular,
        slidesPerView: slidesPerView,
        initialSlide,
        speed: parseInt(String(duration), 10),
        observer: true,
        observeParents: true,
        nested: true,
        loopAdditionalSlides,
        centeredSlides
      }, effectsProps), {
        on: {
          init(_swiper) {
            that.getNeedFixLoop() && _swiper.loopFix();
            that.props.autoplay && _swiper.autoplay.start();
          },
          transitionEnd(_swiper) {
            if (__classPrivateFieldGet(that, _SwiperInner_swiperResetting, "f") || __classPrivateFieldGet(that, _SwiperInner_lastSwiperActiveIndex, "f") === _swiper.realIndex) return;
            __classPrivateFieldSet(that, _SwiperInner_lastSwiperActiveIndex, _swiper.realIndex, "f");
            that.getNeedFixLoop() && _swiper.loopFix();
            that.props.autoplay && _swiper.autoplay.start();
            const e = createEvent('touchend');
            try {
              const currentId = that.getCurrentId(_swiper);
              Object.defineProperty(e, 'detail', {
                enumerable: true,
                value: {
                  source: __classPrivateFieldGet(that, _SwiperInner_source, "f"),
                  current: this.realIndex,
                  currentId: currentId
                }
              });
            } catch (err) {} // eslint-disable-line no-empty
            that.handleOnAnimationFinish(e);
            __classPrivateFieldSet(that, _SwiperInner_source, 'autoplay', "f");
          },
          touchMove() {
            __classPrivateFieldSet(that, _SwiperInner_source, 'touch', "f");
          },
          touchEnd: _swiper => {
            __classPrivateFieldSet(that, _SwiperInner_source, 'touch', "f");
            that.props.autoplay && _swiper.autoplay.start();
          },
          touchStart: _swiper => {
            __classPrivateFieldSet(that, _SwiperInner_source, 'touch', "f");
            that.props.autoplay && _swiper.autoplay.pause();
          },
          slideChange(_swiper) {
            if (__classPrivateFieldGet(that, _SwiperInner_swiperResetting, "f") || __classPrivateFieldGet(that, _SwiperInner_lastSwiperActiveIndex, "f") === _swiper.realIndex) return;
            const e = createEvent('touchend');
            try {
              const currentId = that.getCurrentId(_swiper);
              Object.defineProperty(e, 'detail', {
                enumerable: true,
                value: {
                  current: this.realIndex,
                  source: __classPrivateFieldGet(that, _SwiperInner_source, "f"),
                  currentId
                }
              });
            } catch (err) {} // eslint-disable-line no-empty
            that.handleOnChange(e);
          },
          autoplay(_swiper) {
            // Note: 修复 autoplay 时，切换到其他页面再切回来，autoplay 会停止的问题
            _swiper.animating = false;
            __classPrivateFieldSet(that, _SwiperInner_source, 'autoplay', "f");
          }
        }
      });
      // 自动播放
      if (autoplay) {
        opt.autoplay = {
          delay: parseInt(String(interval), 10),
          disableOnInteraction: false
        };
      }
      _this.swiper = new Swipers(_this.$el, opt);
      // Note: 这里是拦截了 swiper 的 minTranslate 和 maxTranslate 方法，手动修复了 loop 模式下的 margin 问题
      // 因为这两个属性会影响滑动到哪个位置进行 fixloop
      // 可参考源码：https://github.com/nolimits4web/swiper/blob/v11.1.0/src/core/events/onTouchMove.mjs
      // https://github.com/nolimits4web/swiper/blob/v11.1.0/src/core/loop/loopFix.mjs
      if (_this.getNeedFixLoop()) {
        // @ts-ignore
        const minTranslate = _this.swiper.minTranslate.bind(_this.swiper);
        // @ts-ignore
        const maxTranslate = _this.swiper.maxTranslate.bind(_this.swiper);
        if (centeredSlides && _this.getSlidersList().length < 4) {
          // @ts-ignore
          _this.swiper.minTranslate = () => minTranslate() + _this.parseMargin()[1];
          // @ts-ignore
          _this.swiper.maxTranslate = () => maxTranslate() - _this.parseMargin()[0];
        } else {
          // @ts-ignore
          _this.swiper.minTranslate = () => minTranslate() - _this.parseMargin()[0];
          // @ts-ignore
          _this.swiper.maxTranslate = () => maxTranslate() + _this.parseMargin()[1];
        }
      }
      _this.setState({
        swiperWrapper: _this.swiper.wrapperEl
      });
    };
    this.handleSwiperSizeDebounce = debounce(() => {
      if (!this.swiper) return;
      if (this.props.circular) {
        if (__classPrivateFieldGet(this, _SwiperInner_domChangeByOutSide, "f")) {
          this.reset();
          __classPrivateFieldSet(this, _SwiperInner_domChangeByOutSide, false, "f");
        }
      } else {
        this.swiper.update();
        __classPrivateFieldSet(this, _SwiperInner_swiperResetting, false, "f");
      }
    }, 50);
    this.reset = () => {
      if (!this.swiper) return;
      __classPrivateFieldSet(this, _SwiperInner_swiperResetting, true, "f");
      __classPrivateFieldSet(this, _SwiperInner_lastSwiperActiveIndex, this.swiper.realIndex, "f");
      this.swiper.destroy();
      this.handleInit(true);
      __classPrivateFieldSet(this, _SwiperInner_swiperResetting, false, "f");
    };
    // 以下为方法函数
    this.getSlidersList = () => {
      var _a, _b;
      return ((_b = (_a = this.$el) === null || _a === void 0 ? void 0 : _a.querySelectorAll) === null || _b === void 0 ? void 0 : _b.call(_a, '.swiper-slide')) || [];
    };
    // 获取是否需要手动修复 loop 的条件
    this.getNeedFixLoop = () => {
      const margins = this.parseMargin();
      const hasMargin = margins.filter(Boolean).length > 0;
      return this.props.circular && hasMargin;
    };
    this.parseMargin = () => {
      const {
        previousMargin = '0px',
        nextMargin = '0px'
      } = this.props;
      const [, pM] = /^(\d+)px/.exec(previousMargin) || [];
      const [, nN] = /^(\d+)px/.exec(nextMargin) || [];
      return [parseInt(pM) || 0, parseInt(nN) || 0];
    };
    this.state = {
      swiperWrapper: null
    };
  }
  componentDidMount() {
    this.handleInit();
  }
  hackSwiperWrapDomAction() {
    if (!this.state.swiperWrapper || !this.swiper) return;
    const appendChild = this.state.swiperWrapper.appendChild.bind(this.state.swiperWrapper);
    const removeChild = this.state.swiperWrapper.removeChild.bind(this.state.swiperWrapper);
    const replaceChild = this.state.swiperWrapper.replaceChild.bind(this.state.swiperWrapper);
    const insertBefore = this.state.swiperWrapper.insertBefore.bind(this.state.swiperWrapper);
    const beforeAction = () => {
      if (!this.state.swiperWrapper || !this.swiper) return;
      __classPrivateFieldSet(this, _SwiperInner_swiperResetting, true, "f");
      if (!__classPrivateFieldGet(this, _SwiperInner_domChangeByOutSide, "f") && this.props.circular) {
        // 如果是由于外部子节点的变化引起的 dom 变化，需要重新初始化 swiper。
        // 在初dom操作之前，需要调用 loopDestroy，把子节点的顺序恢复
        __classPrivateFieldSet(this, _SwiperInner_domChangeByOutSide, true, "f");
        this.swiper.loopDestroy();
        this.swiper.params.loop = false;
      }
    };
    // eslint-disable-next-line react/no-direct-mutation-state
    this.state.swiperWrapper.appendChild = function () {
      beforeAction();
      return appendChild(...arguments);
    };
    // eslint-disable-next-line react/no-direct-mutation-state
    this.state.swiperWrapper.removeChild = function () {
      beforeAction();
      return removeChild(...arguments);
    };
    // eslint-disable-next-line react/no-direct-mutation-state
    this.state.swiperWrapper.replaceChild = function () {
      beforeAction();
      return replaceChild(...arguments);
    };
    // eslint-disable-next-line react/no-direct-mutation-state
    this.state.swiperWrapper.insertBefore = function () {
      beforeAction();
      return insertBefore(...arguments);
    };
  }
  componentDidUpdate(prevProps, pervState) {
    if (!this.swiper || !this.state.swiperWrapper) return;
    if (pervState.swiperWrapper !== this.state.swiperWrapper && this.state.swiperWrapper) {
      this.observer && this.observer.disconnect();
      this.observer = new MutationObserver(this.handleSwiperSizeDebounce);
      this.observer.observe(this.state.swiperWrapper, {
        childList: true
      });
      this.hackSwiperWrapDomAction();
    }
    if (prevProps.circular !== this.props.circular || prevProps.displayMultipleItems !== this.props.displayMultipleItems) {
      this.reset();
    }
    if (prevProps.interval !== this.props.interval) {
      if (typeof this.swiper.params.autoplay === 'object') {
        this.swiper.params.autoplay.delay = this.props.interval;
      }
    }
    if (prevProps.duration !== this.props.duration) {
      this.swiper.params.speed = this.props.duration;
    }
    if (prevProps.current !== this.props.current && !this.props.currentItemId) {
      const n = parseInt(String(this.props.current), 10);
      if (isNaN(n) || n === this.swiper.realIndex) return;
      __classPrivateFieldSet(this, _SwiperInner_source, '', "f");
      if (this.props.circular) {
        this.swiper.slideToLoop(n); // 更新下标
        this.props.autoplay && this.swiper.autoplay.pause();
        // @ts-ignore
        this.swiper.loopFix();
        this.props.autoplay && this.swiper.autoplay.start();
      } else {
        this.swiper.slideTo(n); // 更新下标
      }
    }
    if (prevProps.autoplay !== this.props.autoplay) {
      const swiperAutoplay = this.swiper.autoplay;
      if (swiperAutoplay) {
        if (swiperAutoplay.running === this.props.autoplay) return;
        if (this.props.autoplay) {
          if (this.swiper.params && typeof this.swiper.params.autoplay === 'object') {
            if (this.swiper.params.autoplay.disableOnInteraction === true) {
              this.swiper.params.autoplay.disableOnInteraction = false;
            }
            this.swiper.params.autoplay.delay = this.props.interval;
          }
          swiperAutoplay.start();
        } else {
          swiperAutoplay.stop();
        }
      }
    }
    if (prevProps.currentItemId !== this.props.currentItemId) {
      let itemIdIndex = 0;
      this.getSlidersList().forEach((swiperItem, index) => {
        const itemId = swiperItem.getAttribute('item-id');
        // @ts-ignore
        if (itemId === this.props.currentItemId) {
          if (this.props.circular) {
            itemIdIndex = Number(swiperItem.getAttribute('data-swiper-slide-index'));
          } else {
            itemIdIndex = index;
          }
        }
      });
      if (isNaN(itemIdIndex) || itemIdIndex === this.swiper.realIndex) return;
      __classPrivateFieldSet(this, _SwiperInner_source, '', "f");
      if (this.props.circular) {
        this.swiper.slideToLoop(itemIdIndex); // 更新下标
        this.props.autoplay && this.swiper.autoplay.pause();
        // @ts-ignore
        this.swiper.loopFix();
        this.props.autoplay && this.swiper.autoplay.start();
      } else {
        this.swiper.slideTo(itemIdIndex); // 更新下标
      }
    }
  }
  componentWillUnmount() {
    var _a, _b, _c, _d;
    this.$el = null;
    (_b = (_a = this.swiper) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
    (_d = (_c = this.observer) === null || _c === void 0 ? void 0 : _c.disconnect) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.setState({
      swiperWrapper: null
    });
  }
  handleOnChange(e) {
    const func = this.props.onChange;
    typeof func === 'function' && func(e);
  }
  handleOnAnimationFinish(e) {
    const func = this.props.onAnimationFinish;
    typeof func === 'function' && func(e);
  }
  // Note: loop 的时候添加 additionalSlides 可以避免循环的时候由于 loopFix 不及时，出现空白的问题。但是并不是 additionalSlides 越多越好，因为 additionalSlides 越多，如果 swiper-item 的数量不够，会导致出现 bug。
  // 目前的策略是 swiper-item 的数量小于等于 5 时，不添加 additionalSlides，大于 5 小于等于 7 时，添加 1 个 additionalSlides，大于 7 时，添加 2 个 additionalSlides。
  getLoopAdditionalSlides() {
    const slidersLength = this.getSlidersList().length;
    if (!this.$el || !this.getNeedFixLoop() || slidersLength < ONE_ADDITIONAL_SLIDES_THRESHOLD) return 0;
    if (slidersLength <= TWO_ADDITIONAL_SLIDES_THRESHOLD) return 1;
    return 2;
  }
  getCurrentId(swiper) {
    const slides = swiper.slides;
    const activeIndex = swiper.activeIndex;
    const currentSlide = slides[activeIndex];
    return currentSlide.getAttribute('item-id');
  }
  render() {
    const {
      className,
      style,
      vertical,
      indicatorColor,
      indicatorActiveColor,
      forwardedRef
    } = this.props;
    const defaultIndicatorColor = indicatorColor || 'rgba(0, 0, 0, .3)';
    const defaultIndicatorActiveColor = indicatorActiveColor || '#000';
    const [pM, nM] = this.parseMargin();
    const cls = classNames(`taro-swiper-${this._id}`, className);
    const sty = Object.assign({
      overflow: 'hidden'
    }, style);
    if (this.props.full) {
      sty.height = '100%';
    }
    const swiperContainerStyleList = ['overflow: visible;', vertical ? `margin-top: ${pM}px; margin-bottom: ${nM}px;` : `margin-right: ${nM}px; margin-left: ${pM}px;`, this.props.full ? 'height: 100%;' : ''];
    const swiperPaginationStyleList = [this.props.indicatorDots ? 'opacity: 1;' : 'display: none;', 'font-size: 0;'];
    return /*#__PURE__*/jsx("div", {
      className: `swiper-container-wrapper ${cls}`,
      style: sty,
      ref: e => {
        if (forwardedRef && e) {
          forwardedRef.current = e;
        }
      },
      children: /*#__PURE__*/jsxs("div", {
        className: "swiper-container",
        style: {
          overflow: 'visible'
        },
        ref: el => {
          this.$el = el;
        },
        children: [/*#__PURE__*/jsx("div", {
          dangerouslySetInnerHTML: {
            __html: `<style type='text/css'>
              .taro-swiper-${this._id} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet { background: ${defaultIndicatorColor} }
              .taro-swiper-${this._id} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet-active { background: ${defaultIndicatorActiveColor} }
              .taro-swiper-${this._id} > .swiper-container { ${swiperContainerStyleList.join('')} }
              .taro-swiper-${this._id} > .swiper-container > .swiper-pagination { ${swiperPaginationStyleList.join('')} }
              </style>`
          }
        }), /*#__PURE__*/jsx("div", {
          className: "swiper-wrapper",
          children: this.props.children
        }), /*#__PURE__*/jsx("div", {
          className: "swiper-pagination"
        })]
      })
    });
  }
}
_SwiperInner_source = new WeakMap(), _SwiperInner_swiperResetting = new WeakMap(), _SwiperInner_lastSwiperActiveIndex = new WeakMap(), _SwiperInner_domChangeByOutSide = new WeakMap();
const Swiper = createForwardRefComponent(SwiperInner);
const SwiperItem = createForwardRefComponent(SwiperItemInner);

export { Swiper, SwiperItem };
//# sourceMappingURL=index.js.map
