'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helper = require('@tarojs/helper');
var shared = require('@tarojs/shared');
var tslib = require('tslib');
var lodash = require('lodash');
var acorn = require('acorn');
var walk = require('acorn-walk');
var path = require('node:path');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var acorn__namespace = /*#__PURE__*/_interopNamespaceDefault(acorn);
var walk__namespace = /*#__PURE__*/_interopNamespaceDefault(walk);

function apiLoader (str) {
    return `import {
  useAddToFavorites,
  useDidHide,
  useDidShow,
  useError,
  useLaunch,
  useLoad,
  useOptionMenuClick,
  usePageNotFound,
  usePageScroll,
  usePullDownRefresh,
  usePullIntercept,
  useReachBottom,
  useReady,
  useResize,
  useRouter,
  useSaveExitState,
  useShareAppMessage,
  useShareTimeline,
  useTabItemTap,
  useTitleClick,
  useScope,
  useUnhandledRejection,
  useUnload
} from '@tarojs/plugin-framework-react/dist/runtime'
${str}

taro.useAddToFavorites = useAddToFavorites
taro.useDidHide = useDidHide
taro.useDidShow = useDidShow
taro.useError = useError
taro.useLaunch = useLaunch
taro.useLoad = useLoad
taro.useOptionMenuClick = useOptionMenuClick
taro.usePageNotFound = usePageNotFound
taro.usePageScroll = usePageScroll
taro.usePullDownRefresh = usePullDownRefresh
taro.usePullIntercept = usePullIntercept
taro.useReachBottom = useReachBottom
taro.useReady = useReady
taro.useResize = useResize
taro.useRouter = useRouter
taro.useSaveExitState = useSaveExitState
taro.useShareAppMessage = useShareAppMessage
taro.useShareTimeline = useShareTimeline
taro.useTabItemTap = useTabItemTap
taro.useTitleClick = useTitleClick
taro.useScope = useScope
taro.useUnhandledRejection = useUnhandledRejection
taro.useUnload = useUnload

export {
  useAddToFavorites,
  useDidHide,
  useDidShow,
  useError,
  useLaunch,
  useLoad,
  useOptionMenuClick,
  usePageNotFound,
  usePageScroll,
  usePullDownRefresh,
  usePullIntercept,
  useReachBottom,
  useReady,
  useResize,
  useRouter,
  useSaveExitState,
  useShareAppMessage,
  useShareTimeline,
  useTabItemTap,
  useTitleClick,
  useScope,
  useUnhandledRejection,
  useUnload
}
`;
}

function addConfig(source) {
    const configsMap = {
        enableShareAppMessage: ['onShareAppMessage', 'useShareAppMessage'],
        enableShareTimeline: ['onShareTimeline', 'useShareTimeline']
    };
    const ast = acorn__namespace.parse(source, {
        ecmaVersion: 'latest',
        sourceType: 'module'
    });
    const additionConfig = {};
    function check(name) {
        Object.keys(configsMap).forEach(configName => {
            const apis = configsMap[configName];
            if (apis.includes(name)) {
                additionConfig[configName] = true;
            }
        });
    }
    walk__namespace.simple(ast, {
        FunctionExpression(node) {
            if (!node.id || !node.id.name)
                return;
            check(node.id.name);
        },
        FunctionDeclaration(node) {
            if (!node.id || !node.id.name)
                return;
            check(node.id.name);
        },
        CallExpression(node) {
            const { callee } = node;
            if (callee.type === 'Identifier') {
                check(callee.name);
            }
            else if (callee.type === 'MemberExpression') {
                if (callee.property.type === 'Identifier') {
                    check(callee.property.name);
                }
                else if (callee.property.type === 'Literal') {
                    check(callee.property.value);
                }
            }
            node.arguments.forEach(item => {
                if (item.type === 'Literal' && item.value) {
                    check(item.value);
                }
            });
        }
    });
    return additionConfig;
}
function getLoaderMeta(framework) {
    const loaderMeta = {
        importFrameworkStatement: `
import * as React from 'react'
import ReactDOM from 'react-dom'
`,
        mockAppStatement: `
class App extends React.Component {
  render () {
    return this.props.children
  }
}
`,
        frameworkArgs: 'React, ReactDOM, config',
        creator: 'createReactApp',
        creatorLocation: '@tarojs/plugin-framework-react/dist/runtime',
        importFrameworkName: 'React',
        extraImportForWeb: '',
        execBeforeCreateWebApp: '',
        modifyConfig(config, source) {
            Object.assign(config, addConfig(source));
        }
    };
    if (process.env.TARO_PLATFORM === 'web') {
        if (framework === 'react') {
            const react = require('react');
            const majorVersion = Number((react.version || '18').split('.')[0]);
            if (majorVersion >= 18) {
                // Note: In react 18 or above, should using react-dom/client
                loaderMeta.importFrameworkStatement = loaderMeta.importFrameworkStatement.replace('\'react-dom\'', '\'react-dom/client\'');
                loaderMeta.extraImportForWeb += `import { findDOMNode, render, unstable_batchedUpdates } from 'react-dom'\n`;
                loaderMeta.execBeforeCreateWebApp += `Object.assign(ReactDOM, { findDOMNode, render, unstable_batchedUpdates })\n`;
            }
        }
    }
    return loaderMeta;
}

function h5iVitePlugin(ctx, framework) {
    return [
        injectLoaderMeta$2(ctx, framework),
        setTaroApi(),
        esbuildExclude(framework)
    ];
}
function injectLoaderMeta$2(ctx, framework) {
    function customizer(object = '', sources = '') {
        if ([object, sources].every(e => typeof e === 'string'))
            return object + sources;
    }
    const { runnerUtils } = ctx;
    const { getViteH5CompilerContext } = runnerUtils;
    return {
        name: 'taro-react:loader-meta',
        buildStart() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const viteCompilerContext = yield getViteH5CompilerContext(this);
                if (viteCompilerContext) {
                    viteCompilerContext.loaderMeta = lodash.mergeWith(getLoaderMeta(framework), viteCompilerContext.loaderMeta, customizer);
                }
            });
        }
    };
}
function setTaroApi() {
    // dev 环境通过 esbuild 来做； pro 环境通过 rollup load 钩子来做；因为生产环境不会走 esbuild
    return {
        name: 'taro-react:process-import-taro',
        enforce: 'pre',
        config: () => ({
            optimizeDeps: {
                esbuildOptions: {
                    plugins: [
                        {
                            name: 'taro:react-api',
                            setup(build) {
                                build.onLoad({ filter: helper.REG_TARO_H5_RUNTIME_API }, (args) => tslib.__awaiter(this, void 0, void 0, function* () {
                                    const input = yield helper.fs.readFile(args.path, 'utf8');
                                    return {
                                        contents: apiLoader(input + '\n' + 'const taro = Taro__default\n')
                                    };
                                }));
                            },
                        }
                    ]
                }
            },
        }),
        load(id) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (process.env.NODE_ENV === 'production' && helper.REG_TARO_H5_RUNTIME_API.test(id)) {
                    try {
                        const input = yield helper.fs.readFile(id, 'utf8');
                        return apiLoader(input + '\n' + 'const taro = Taro__default\n');
                    }
                    catch (_) {
                        return null;
                    }
                }
            });
        }
    };
}
// todo 后面看看能否把 preact 改为虚拟模块
function esbuildExclude(framework) {
    if (framework !== 'preact')
        return null;
    return {
        name: 'taro-react:esvuild-exclude',
        enforce: 'pre',
        config: () => ({
            optimizeDeps: {
                exclude: ['react', 'preact']
            }
        })
    };
}

function harmonyVitePlugin(ctx, framework) {
    return [
        injectLoaderMeta$1(ctx, framework),
        aliasPlugin$1(ctx, framework),
    ];
}
function injectLoaderMeta$1(ctx, framework) {
    return {
        name: 'taro-react:loader-meta',
        buildStart() {
            const { runnerUtils } = ctx;
            const { getViteHarmonyCompilerContext } = runnerUtils;
            const viteCompilerContext = getViteHarmonyCompilerContext(this);
            if (viteCompilerContext) {
                viteCompilerContext.loaderMeta || (viteCompilerContext.loaderMeta = {});
                Object.assign(viteCompilerContext.loaderMeta, getLoaderMeta(framework));
            }
        }
    };
}
function aliasPlugin$1(ctx, framework) {
    if (framework === 'react') {
        return {
            name: 'taro-react:alias',
            config(config) {
                var _a;
                const alias = [
                    { find: /react-dom$/, replacement: '@tarojs/react' },
                    { find: /react-dom\/client$/, replacement: '@tarojs/react' },
                ];
                const mainFields = ['unpkg', ...helper.defaultMainFields];
                const resolveOptions = {
                    basedir: process.cwd(),
                    mainFields,
                };
                const isProd = config.mode === 'production';
                // TODO：harmony 目前会导致部分包用 production 版本，部分用 development 版本，导致许多 api 报错
                const isHarmony = ctx.runOpts.options.platform === 'harmony';
                if (!isProd && ((_a = ctx.initialConfig.harmony) === null || _a === void 0 ? void 0 : _a.debugReact) !== true && !isHarmony) {
                    // 在React18中，使用了exports字段约定了模块暴露路径，其中并未暴露 ./cjs/ 。这将使上面的alias在编译时报错。相当的tricky。
                    // Why writeJson？ prebundle will load package.json via readFile to check exports property.
                    const reactPkgPath = helper.resolveSync('react/package.json', resolveOptions);
                    if (reactPkgPath) {
                        const reactPkg = require('react/package.json');
                        const reactVersion = (reactPkg.version || '');
                        if ((/^[~^]?18/).test(reactVersion) && reactPkg.exports) {
                            reactPkg.exports = Object.assign(reactPkg.exports, {
                                './cjs/': './cjs/'
                            });
                            helper.fs.writeJsonSync(reactPkgPath, reactPkg, { spaces: 2 });
                        }
                    }
                }
                return {
                    resolve: {
                        alias
                    }
                };
            }
        };
    }
    return [];
}

function miniVitePlugin(ctx, framework) {
    return [
        injectLoaderMeta(ctx, framework),
        aliasPlugin(ctx, framework),
    ];
}
function injectLoaderMeta(ctx, framework) {
    return {
        name: 'taro-react:loader-meta',
        buildStart() {
            const { runnerUtils } = ctx;
            const { getViteMiniCompilerContext } = runnerUtils;
            const viteCompilerContext = getViteMiniCompilerContext(this);
            if (viteCompilerContext) {
                viteCompilerContext.loaderMeta || (viteCompilerContext.loaderMeta = {});
                Object.assign(viteCompilerContext.loaderMeta, getLoaderMeta(framework));
            }
        }
    };
}
function aliasPlugin(ctx, framework) {
    if (framework === 'react') {
        return {
            name: 'taro-react:alias',
            config(config) {
                var _a;
                const alias = [
                    { find: /react-dom$/, replacement: '@tarojs/react' },
                    { find: /react-dom\/client$/, replacement: '@tarojs/react' },
                ];
                const mainFields = ['unpkg', ...helper.defaultMainFields];
                const resolveOptions = {
                    basedir: process.cwd(),
                    mainFields,
                };
                const isProd = config.mode === 'production';
                // TODO：harmony 目前会导致部分包用 production 版本，部分用 development 版本，导致许多 api 报错
                const isHarmony = ctx.runOpts.options.platform === 'harmony';
                if (!isProd && ((_a = ctx.initialConfig.mini) === null || _a === void 0 ? void 0 : _a.debugReact) !== true && !isHarmony) {
                    // 不是生产环境，且没有设置 debugReact，则使用压缩版本的 react 依赖，减少体积
                    alias.push({ find: /react-reconciler$/, replacement: 'react-reconciler/cjs/react-reconciler.production.min.js' });
                    alias.push({ find: /^(?!.*mobx-react$).*react$/, replacement: 'react/cjs/react.production.min.js' });
                    alias.push({ find: /scheduler$/, replacement: 'scheduler/cjs/scheduler.production.min.js' });
                    alias.push({ find: /react\/jsx-runtime$/, replacement: 'react/cjs/react-jsx-runtime.production.min.js' });
                    // 在React18中，使用了exports字段约定了模块暴露路径，其中并未暴露 ./cjs/ 。这将使上面的alias在编译时报错。相当的tricky。
                    // Why writeJson？ prebundle will load package.json via readFile to check exports property.
                    const reactPkgPath = helper.resolveSync('react/package.json', resolveOptions);
                    if (reactPkgPath) {
                        const reactPkg = require('react/package.json');
                        const reactVersion = (reactPkg.version || '');
                        if ((/^[~^]?18/).test(reactVersion) && reactPkg.exports) {
                            reactPkg.exports = Object.assign(reactPkg.exports, {
                                './cjs/': './cjs/'
                            });
                            helper.fs.writeJsonSync(reactPkgPath, reactPkg, { spaces: 2 });
                        }
                    }
                }
                return {
                    resolve: {
                        alias
                    }
                };
            }
        };
    }
    return [];
}

function modifyH5WebpackChain(ctx, framework, chain) {
    var _a;
    setLoader$2(framework, chain);
    setPlugin(ctx, framework, chain);
    const { isBuildNativeComp = false } = ((_a = ctx.runOpts) === null || _a === void 0 ? void 0 : _a.options) || {};
    const externals = {};
    if (isBuildNativeComp) {
        // Note: 该模式不支持 prebundle 优化，不必再处理
        externals.react = {
            commonjs: 'react',
            commonjs2: 'react',
            amd: 'react',
            root: 'React'
        };
        externals['react-dom'] = {
            commonjs: 'react-dom',
            commonjs2: 'react-dom',
            amd: 'react-dom',
            root: 'ReactDOM'
        };
        if (framework === 'preact') {
            externals.preact = 'preact';
        }
        chain.merge({
            externalsType: 'umd'
        });
    }
    chain.merge({
        externals,
        module: {
            rule: {
                'process-import-taro-h5': {
                    test: helper.REG_TARO_H5,
                    loader: require.resolve('./api-loader'),
                },
            },
        },
    });
}
function setLoader$2(framework, chain) {
    function customizer(object = '', sources = '') {
        if ([object, sources].every((e) => typeof e === 'string'))
            return object + sources;
    }
    chain.plugin('mainPlugin').tap((args) => {
        args[0].loaderMeta = lodash.mergeWith(getLoaderMeta(framework), args[0].loaderMeta, customizer);
        return args;
    });
}
function setPlugin(ctx, framework, chain) {
    var _a, _b;
    const config = ctx.initialConfig;
    const webpackConfig = chain.toConfig();
    const isProd = webpackConfig.mode === 'production';
    if (!isProd && ((_b = (_a = config.h5) === null || _a === void 0 ? void 0 : _a.devServer) === null || _b === void 0 ? void 0 : _b.hot) !== false) {
        // 默认开启 fast-refresh
        if (framework === 'react') {
            chain.plugin('fastRefreshPlugin').use(require('@pmmmwh/react-refresh-webpack-plugin'));
        }
        else if (framework === 'preact') {
            chain.plugin('hotModuleReplacementPlugin').use(require('webpack').HotModuleReplacementPlugin);
            chain.plugin('fastRefreshPlugin').use(require('@prefresh/webpack'));
        }
    }
    const mainFields = ['unpkg', ...helper.defaultMainFields];
    const resolveOptions = {
        basedir: process.cwd(),
        mainFields,
    };
    if (framework === 'react') {
        const alias = chain.resolve.alias;
        // Note: 本地 link 调试时，避免 react 重复打包
        alias.set('react$', helper.resolveSync('react', resolveOptions));
        alias.set('react-dom$', helper.resolveSync('react-dom', resolveOptions));
    }
}

function modifyHarmonyWebpackChain(ctx, framework, chain) {
    setAlias$2(ctx, framework, chain);
    setLoader$1(framework, chain);
}
function setAlias$2(ctx, framework, chain) {
    var _a;
    const config = ctx.initialConfig;
    const alias = chain.resolve.alias;
    const mainFields = ['unpkg', ...helper.defaultMainFields];
    const resolveOptions = {
        basedir: process.cwd(),
        mainFields,
    };
    if (framework === 'react') {
        alias.set('react-dom$', '@tarojs/react');
        alias.set('react-dom/client$', '@tarojs/react');
        const webpackConfig = chain.toConfig();
        const isProd = webpackConfig.mode === 'production';
        if (!isProd && ((_a = config.harmony) === null || _a === void 0 ? void 0 : _a.debugReact) !== true) {
            // 不是生产环境，且没有设置 debugReact，则使用压缩版本的 react 依赖，减少体积
            // 兼容pnpm workspace
            const reactModulePath = helper.resolveSync('react', resolveOptions);
            const newFilePath = path.join(path.dirname(reactModulePath), 'cjs', 'react.production.min.js');
            alias.set('react-reconciler$', 'react-reconciler/cjs/react-reconciler.production.min.js');
            alias.set('react$', newFilePath);
            alias.set('react/jsx-runtime$', 'react/cjs/react-jsx-runtime.production.min.js');
            // 在React18中，使用了exports字段约定了模块暴露路径，其中并未暴露 ./cjs/ 。这将使上面的alias在编译时报错。相当的tricky。
            // Why writeJson？ prebundle will load package.json via readFile to check exports property.
            const reactPkgPath = helper.resolveSync('react/package.json', resolveOptions);
            if (reactPkgPath) {
                const reactPkg = require('react/package.json');
                const reactVersion = reactPkg.version || '';
                if (/^[~^]?18/.test(reactVersion) && reactPkg.exports) {
                    reactPkg.exports = Object.assign(reactPkg.exports, {
                        './cjs/': './cjs/',
                    });
                    helper.fs.writeJsonSync(reactPkgPath, reactPkg, { spaces: 2 });
                }
            }
        }
    }
}
function setLoader$1(framework, chain) {
    chain.plugin('mainPlugin').tap((args) => {
        var _a;
        (_a = args[0]).loaderMeta || (_a.loaderMeta = {});
        Object.assign(args[0].loaderMeta, getLoaderMeta(framework));
        return args;
    });
}

function modifyMiniWebpackChain(ctx, framework, chain) {
    setAlias$1(ctx, framework, chain);
    setLoader(framework, chain);
}
function setAlias$1(ctx, framework, chain) {
    var _a;
    const config = ctx.initialConfig;
    const alias = chain.resolve.alias;
    const mainFields = ['unpkg', ...helper.defaultMainFields];
    const resolveOptions = {
        basedir: process.cwd(),
        mainFields,
    };
    if (framework === 'react') {
        alias.set('react-dom$', '@tarojs/react');
        alias.set('react-dom/client$', '@tarojs/react');
        const webpackConfig = chain.toConfig();
        const isProd = webpackConfig.mode === 'production';
        if (!isProd && ((_a = config.mini) === null || _a === void 0 ? void 0 : _a.debugReact) !== true) {
            // 不是生产环境，且没有设置 debugReact，则使用压缩版本的 react 依赖，减少体积
            // 兼容pnpm workspace
            const reactModulePath = helper.resolveSync('react', resolveOptions);
            const newFilePath = path.join(path.dirname(reactModulePath), 'cjs', 'react.production.min.js');
            alias.set('react-reconciler$', 'react-reconciler/cjs/react-reconciler.production.min.js');
            alias.set(/^(?!.*mobx-react$).*react$/, newFilePath);
            alias.set('react/jsx-runtime$', 'react/cjs/react-jsx-runtime.production.min.js');
            // 在React18中，使用了exports字段约定了模块暴露路径，其中并未暴露 ./cjs/ 。这将使上面的alias在编译时报错。相当的tricky。
            // Why writeJson？ prebundle will load package.json via readFile to check exports property.
            const reactPkgPath = helper.resolveSync('react/package.json', resolveOptions);
            if (reactPkgPath) {
                const reactPkg = require('react/package.json');
                const reactVersion = reactPkg.version || '';
                if (/^[~^]?18/.test(reactVersion) && reactPkg.exports) {
                    reactPkg.exports = Object.assign(reactPkg.exports, {
                        './cjs/': './cjs/',
                    });
                    helper.fs.writeJsonSync(reactPkgPath, reactPkg, { spaces: 2 });
                }
            }
        }
    }
}
function setLoader(framework, chain) {
    chain.plugin('miniPlugin').tap((args) => {
        var _a;
        (_a = args[0]).loaderMeta || (_a.loaderMeta = {});
        Object.assign(args[0].loaderMeta, getLoaderMeta(framework));
        return args;
    });
}

function isReactLike(framework = 'react') {
    return ['react', 'preact'].includes(framework);
}
var index = (ctx) => {
    const { framework = 'react' } = ctx.initialConfig;
    if (!isReactLike(framework))
        return;
    ctx.modifyWebpackChain(({ chain }) => {
        // 通用
        setAlias(framework, chain);
        if (process.env.TARO_PLATFORM === 'web') {
            // H5
            modifyH5WebpackChain(ctx, framework, chain);
        }
        else if (process.env.TARO_PLATFORM === 'harmony' || process.env.TARO_ENV === 'harmony') {
            // 鸿蒙
            modifyHarmonyWebpackChain(ctx, framework, chain);
        }
        else {
            // 小程序
            modifyMiniWebpackChain(ctx, framework, chain);
        }
    });
    ctx.modifyRunnerOpts(({ opts }) => {
        if (!(opts === null || opts === void 0 ? void 0 : opts.compiler))
            return;
        if (shared.isString(opts.compiler)) {
            opts.compiler = {
                type: opts.compiler,
            };
        }
        const { compiler } = opts;
        if (compiler.type === 'webpack5') {
            // 提供给 webpack5 依赖预编译收集器的第三方依赖
            const deps = ['react', 'react-dom', 'react/jsx-runtime', '@tarojs/plugin-framework-react/dist/runtime'];
            compiler.prebundle || (compiler.prebundle = {});
            const prebundleOptions = compiler.prebundle;
            prebundleOptions.include || (prebundleOptions.include = []);
            prebundleOptions.include = prebundleOptions.include.concat(deps);
            prebundleOptions.exclude || (prebundleOptions.exclude = []);
            prebundleOptions.exclude.push(/mobx/); // 依赖会对 webpack 修改，默认排除
            if (prebundleOptions.enable === false)
                return;
            const taroReactPlugin = {
                name: 'taroReactPlugin',
                setup(build) {
                    build.onLoad({ filter: helper.REG_TARO_H5 }, ({ path }) => {
                        const content = helper.fs.readFileSync(path).toString();
                        return {
                            contents: require('./api-loader')(content),
                        };
                    });
                }
            };
            prebundleOptions.esbuild || (prebundleOptions.esbuild = {});
            const esbuildConfig = prebundleOptions.esbuild;
            esbuildConfig.plugins || (esbuildConfig.plugins = []);
            esbuildConfig.plugins.push(taroReactPlugin);
        }
        else if (compiler.type === 'vite') {
            compiler.vitePlugins || (compiler.vitePlugins = []);
            compiler.vitePlugins.push(viteCommonPlugin(framework));
            compiler.vitePlugins.push(VitePresetPlugin(framework));
            if (process.env.TARO_PLATFORM === 'web') {
                // H5
                compiler.vitePlugins.push(h5iVitePlugin(ctx, framework));
            }
            else if (process.env.TARO_PLATFORM === 'harmony' || process.env.TARO_ENV === 'harmony') {
                // 鸿蒙
                compiler.vitePlugins.push(harmonyVitePlugin(ctx, framework));
            }
            else {
                // 小程序
                compiler.vitePlugins.push(miniVitePlugin(ctx, framework));
            }
        }
    });
};
function setAlias(framework, chain) {
    const alias = chain.resolve.alias;
    if (framework === 'preact') {
        alias.set('react', 'preact/compat');
        alias.set('react-dom/test-utils', 'preact/test-utils');
        alias.set('react-dom', 'preact/compat');
        alias.set('react/jsx-runtime', 'preact/jsx-runtime');
    }
}
function VitePresetPlugin(framework) {
    return framework === 'preact'
        ? require('@preact/preset-vite').preact({
            babel: {
                plugins: [
                    ['@babel/plugin-proposal-decorators', { legacy: true }],
                    ['@babel/plugin-proposal-class-properties', { loose: true }],
                ],
            },
        })
        : require('@vitejs/plugin-react').default({
            babel: {
                plugins: [
                    ['@babel/plugin-proposal-decorators', { legacy: true }],
                    ['@babel/plugin-proposal-class-properties', { loose: true }],
                ],
            },
        });
}
function viteCommonPlugin(framework) {
    return {
        name: 'taro-react:common',
        config() {
            const alias = framework === 'preact'
                ? [
                    { find: 'react', replacement: 'preact/compat' },
                    { find: 'react-dom/test-utils', replacement: 'preact/test-utils' },
                    { find: 'react-dom', replacement: 'preact/compat' },
                    { find: 'react/jsx-runtime', replacement: 'preact/jsx-runtime' },
                ]
                : [];
            return {
                resolve: {
                    alias,
                },
            };
        },
    };
}

exports.default = index;
exports.isReactLike = isReactLike;
//# sourceMappingURL=index.js.map
