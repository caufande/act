{"version":3,"file":"generateUrls.js","sourceRoot":"","sources":["generateUrls.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Universal Router (https://www.kriasoft.com/universal-router/)\n *\n * Copyright (c) 2015-present Kriasoft.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nimport {\n  parse,\n  ParseOptions,\n  tokensToFunction,\n  TokensToFunctionOptions,\n  PathFunction,\n} from 'path-to-regexp'\nimport UniversalRouter, { Route, Routes } from './UniversalRouter'\n\nexport interface UrlParams {\n  [paramName: string]: string | number | (string | number)[]\n}\n\nexport interface GenerateUrlsOptions extends ParseOptions, TokensToFunctionOptions {\n  /**\n   * Add a query string to generated url based on unknown route params.\n   */\n  stringifyQueryParams?: (params: UrlParams) => string\n  /**\n   * Generates a unique route name based on all parent routes with the specified separator.\n   */\n  uniqueRouteNameSep?: string\n}\n\n/**\n * Create a url by route name from route path.\n */\ndeclare const generateUrl: (routeName: string, params?: UrlParams) => string\n\ntype GenerateUrl = typeof generateUrl\n\ntype Keys = { [key: string]: boolean }\n\nfunction cacheRoutes(\n  routesByName: Map<string, Route>,\n  route: Route,\n  routes: Routes | null | undefined,\n  name?: string,\n  sep?: string,\n): void {\n  if (route.name && name && routesByName.has(name)) {\n    throw new Error(`Route \"${name}\" already exists`)\n  }\n\n  if (route.name && name) {\n    routesByName.set(name, route)\n  }\n\n  if (routes) {\n    for (let i = 0; i < routes.length; i++) {\n      const childRoute = routes[i]\n      const childName = childRoute.name\n      childRoute.parent = route\n      cacheRoutes(\n        routesByName,\n        childRoute,\n        childRoute.children,\n        name && sep ? (childName ? name + sep + childName : name) : childName,\n        sep,\n      )\n    }\n  }\n}\n\n/**\n * Create a function to generate urls by route names.\n */\nfunction generateUrls(router: UniversalRouter, options?: GenerateUrlsOptions): GenerateUrl {\n  if (!router) {\n    throw new ReferenceError('Router is not defined')\n  }\n\n  const routesByName = new Map<string, Route>()\n  const regexpByRoute = new Map<Route, { toPath: PathFunction<UrlParams>; keys: Keys }>()\n  const opts: GenerateUrlsOptions = { encode: encodeURIComponent, ...options }\n  return (routeName: string, params?: UrlParams): string => {\n    let route = routesByName.get(routeName)\n    if (!route) {\n      routesByName.clear()\n      regexpByRoute.clear()\n      cacheRoutes(\n        routesByName,\n        router.root,\n        router.root.children,\n        router.root.name,\n        opts.uniqueRouteNameSep,\n      )\n\n      route = routesByName.get(routeName)\n      if (!route) {\n        throw new Error(`Route \"${routeName}\" not found`)\n      }\n    }\n\n    let regexp = regexpByRoute.get(route)\n    if (!regexp) {\n      let fullPath = ''\n      let rt: Route | null | undefined = route\n      while (rt) {\n        const path = Array.isArray(rt.path) ? rt.path[0] : rt.path\n        if (path) {\n          fullPath = path + fullPath\n        }\n        rt = rt.parent\n      }\n      const tokens = parse(fullPath, opts)\n      const toPath = tokensToFunction(tokens, opts)\n      const keys: Keys = Object.create(null)\n      for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i]\n        if (typeof token !== 'string') {\n          keys[token.name] = true\n        }\n      }\n      regexp = { toPath, keys }\n      regexpByRoute.set(route, regexp)\n    }\n\n    let url = router.baseUrl + regexp.toPath(params) || '/'\n\n    if (opts.stringifyQueryParams && params) {\n      const queryParams: UrlParams = {}\n      const keys = Object.keys(params)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        if (!regexp.keys[key]) {\n          queryParams[key] = params[key]\n        }\n      }\n      const query = opts.stringifyQueryParams(queryParams)\n      if (query) {\n        url += query.charAt(0) === '?' ? query : `?${query}`\n      }\n    }\n\n    return url\n  }\n}\n\nexport default generateUrls\n"]}