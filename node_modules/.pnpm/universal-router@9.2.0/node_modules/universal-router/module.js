/*! Universal Router | MIT License | https://www.kriasoft.com/universal-router/ */

import { match } from 'path-to-regexp';

function decode(val) {
  try {
    return decodeURIComponent(val);
  } catch (err) {
    return val;
  }
}

function matchRoute(route, baseUrl, options, pathname, parentParams) {
  var matchResult;
  var childMatches;
  var childIndex = 0;
  return {
    next: function next(routeToSkip) {
      if (route === routeToSkip) {
        return {
          done: true,
          value: false
        };
      }

      if (!matchResult) {
        var rt = route;
        var end = !rt.children;

        if (!rt.match) {
          rt.match = match(rt.path || '', Object.assign({
            end: end
          }, options));
        }

        matchResult = rt.match(pathname);

        if (matchResult) {
          var _matchResult = matchResult,
              path = _matchResult.path;
          matchResult.path = !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path;
          matchResult.params = Object.assign({}, parentParams, matchResult.params);
          return {
            done: false,
            value: {
              route: route,
              baseUrl: baseUrl,
              path: matchResult.path,
              params: matchResult.params
            }
          };
        }
      }

      if (matchResult && route.children) {
        while (childIndex < route.children.length) {
          if (!childMatches) {
            var childRoute = route.children[childIndex];
            childRoute.parent = route;
            childMatches = matchRoute(childRoute, baseUrl + matchResult.path, options, pathname.substr(matchResult.path.length), matchResult.params);
          }

          var childMatch = childMatches.next(routeToSkip);

          if (!childMatch.done) {
            return {
              done: false,
              value: childMatch.value
            };
          }

          childMatches = null;
          childIndex++;
        }
      }

      return {
        done: true,
        value: false
      };
    }
  };
}

function resolveRoute(context, params) {
  if (typeof context.route.action === 'function') {
    return context.route.action(context, params);
  }

  return undefined;
}

function isChildRoute(parentRoute, childRoute) {
  var route = childRoute;

  while (route) {
    route = route.parent;

    if (route === parentRoute) {
      return true;
    }
  }

  return false;
}

var UniversalRouter = function () {
  function UniversalRouter(routes, options) {
    if (!routes || typeof routes !== 'object') {
      throw new TypeError('Invalid routes');
    }

    this.options = Object.assign({
      decode: decode
    }, options);
    this.baseUrl = this.options.baseUrl || '';
    this.root = Array.isArray(routes) ? {
      path: '',
      children: routes,
      parent: null
    } : routes;
    this.root.parent = null;
  }

  var _proto = UniversalRouter.prototype;

  _proto.resolve = function resolve(pathnameOrContext) {
    var _this = this;

    var context = Object.assign({
      router: this
    }, this.options.context, typeof pathnameOrContext === 'string' ? {
      pathname: pathnameOrContext
    } : pathnameOrContext);
    var matchResult = matchRoute(this.root, this.baseUrl, this.options, context.pathname.substr(this.baseUrl.length));
    var resolve = this.options.resolveRoute || resolveRoute;
    var matches;
    var nextMatches;
    var currentContext = context;

    function next(resume, parent, prevResult) {
      if (parent === void 0) {
        parent = !matches.done && matches.value.route;
      }

      var routeToSkip = prevResult === null && !matches.done && matches.value.route;
      matches = nextMatches || matchResult.next(routeToSkip);
      nextMatches = null;

      if (!resume) {
        if (matches.done || !isChildRoute(parent, matches.value.route)) {
          nextMatches = matches;
          return Promise.resolve(null);
        }
      }

      if (matches.done) {
        var error = new Error('Route not found');
        error.status = 404;
        return Promise.reject(error);
      }

      currentContext = Object.assign({}, context, matches.value);
      return Promise.resolve(resolve(currentContext, matches.value.params)).then(function (result) {
        if (result !== null && result !== undefined) {
          return result;
        }

        return next(resume, parent, result);
      });
    }

    context.next = next;
    return Promise.resolve().then(function () {
      return next(true, _this.root);
    })["catch"](function (error) {
      if (_this.options.errorHandler) {
        return _this.options.errorHandler(error, currentContext);
      }

      throw error;
    });
  };

  return UniversalRouter;
}();

export default UniversalRouter;
//# sourceMappingURL=module.js.map
