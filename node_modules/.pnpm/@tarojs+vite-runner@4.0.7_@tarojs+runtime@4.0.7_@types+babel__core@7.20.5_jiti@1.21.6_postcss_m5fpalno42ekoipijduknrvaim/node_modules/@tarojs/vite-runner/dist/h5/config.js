"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const helper_1 = require("@tarojs/helper");
const runner_utils_1 = require("@tarojs/runner-utils");
const shared_1 = require("@tarojs/shared");
const lodash_1 = require("lodash");
const postcss_h5_1 = require("../postcss/postcss.h5");
const utils_1 = require("../utils");
const constants_1 = require("../utils/constants");
const html_1 = require("../utils/html");
function default_1(viteCompilerContext) {
    var _a;
    const { taroConfig, cwd: appPath, app, sourceDir } = viteCompilerContext;
    const routerMode = ((_a = taroConfig.router) === null || _a === void 0 ? void 0 : _a.mode) || 'hash';
    const isMultiRouterMode = routerMode === 'multi';
    const isProd = (0, utils_1.getMode)(taroConfig) === 'production';
    function parsePublicPath(publicPath = '/') {
        return ['', 'auto'].includes(publicPath) ? publicPath : (0, utils_1.addTrailingSlash)(publicPath);
    }
    function getDefineOption() {
        const { env = {}, defineConstants = {}, framework = 'react', buildAdapter = helper_1.PLATFORMS.H5, useDeprecatedAdapterComponent = false } = taroConfig;
        env.FRAMEWORK = JSON.stringify(framework);
        env.TARO_ENV = JSON.stringify(buildAdapter);
        env.TARO_PLATFORM = JSON.stringify(process.env.TARO_PLATFORM || shared_1.PLATFORM_TYPE.WEB);
        env.SUPPORT_DINGTALK_NAVIGATE = env.SUPPORT_DINGTALK_NAVIGATE || '"disabled"';
        env.SUPPORT_TARO_POLYFILL = env.SUPPORT_TARO_POLYFILL || '"disabled"';
        const envConstants = Object.keys(env).reduce((target, key) => {
            target[`process.env.${key}`] = env[key];
            return target;
        }, {});
        defineConstants.DEPRECATED_ADAPTER_COMPONENT = JSON.stringify(!!useDeprecatedAdapterComponent);
        return Object.assign(Object.assign({}, envConstants), defineConstants);
    }
    function getAliasOption() {
        const alias = taroConfig.alias || {};
        return Object.entries(alias).map(([find, replacement]) => {
            return { find, replacement };
        });
    }
    function getSassOption() {
        return __awaiter(this, void 0, void 0, function* () {
            const sassLoaderOption = taroConfig.sassLoaderOption;
            const option = Object.assign(Object.assign({}, (yield (0, runner_utils_1.getSassLoaderOption)(taroConfig))), sassLoaderOption);
            return {
                scss: option,
                sass: option,
            };
        });
    }
    function getAssetsInlineLimit() {
        var _a, _b;
        const urlOptions = (0, lodash_1.get)(taroConfig, 'postcss.url', {});
        const url = (_a = urlOptions.config) === null || _a === void 0 ? void 0 : _a.url;
        const maxSize = (_b = urlOptions.config) === null || _b === void 0 ? void 0 : _b.maxSize;
        // 如果 enable 等于 false，不给转 base64
        if (urlOptions.enable === false)
            return 0;
        if (url === 'inline') {
            // inline 模式下可以转 base64
            let _maxSize = Number.MAX_SAFE_INTEGER;
            if ((0, shared_1.isNumber)(maxSize))
                _maxSize = maxSize;
            return _maxSize;
        }
        return 0;
    }
    const __postcssOption = (0, postcss_h5_1.getDefaultPostcssConfig)({
        designWidth: taroConfig.designWidth,
        deviceRatio: taroConfig.deviceRatio,
        option: taroConfig.postcss,
        esnextModules: taroConfig.esnextModules || []
    });
    const [, pxtransformOption] = __postcssOption.find(([name]) => name === 'postcss-pxtransform') || [];
    const serverOption = taroConfig.devServer || {};
    let headers = {};
    if ((0, shared_1.isObject)(serverOption.headers)) {
        headers = serverOption.headers;
    }
    let hmr = true;
    if ((0, shared_1.isBoolean)(serverOption.hot)) {
        hmr = serverOption.hot;
    }
    let open = true;
    if ((0, shared_1.isBoolean)(serverOption.open) || (0, shared_1.isString)(serverOption.open)) {
        open = serverOption.open;
    }
    const mode = (0, utils_1.getMode)(taroConfig);
    const mainFields = [...helper_1.defaultMainFields];
    if (!isProd) {
        mainFields.unshift('main:h5');
    }
    return {
        name: 'taro:vite-h5-config',
        enforce: 'pre',
        config: () => __awaiter(this, void 0, void 0, function* () {
            var _b, _c, _d;
            return ({
                root: sourceDir,
                base: parsePublicPath(taroConfig.publicPath),
                mode,
                build: {
                    outDir: node_path_1.default.join(appPath, taroConfig.outputRoot),
                    target: taroConfig.legacy ? undefined : 'es6',
                    cssCodeSplit: true,
                    emptyOutDir: false,
                    watch: taroConfig.isWatch ? {} : null,
                    // @TODO doc needed: sourcemapType not supported
                    sourcemap: (_c = (_b = taroConfig.enableSourceMap) !== null && _b !== void 0 ? _b : taroConfig.isWatch) !== null && _c !== void 0 ? _c : !isProd,
                    chunkSizeWarningLimit: Number.MAX_SAFE_INTEGER,
                    rollupOptions: {
                        output: {
                            entryFileNames: ({ facadeModuleId }) => {
                                if (facadeModuleId === null || facadeModuleId === void 0 ? void 0 : facadeModuleId.startsWith(sourceDir))
                                    return 'js/app.[hash].js';
                                return 'js/[name].[hash].js';
                            },
                            chunkFileNames: taroConfig.output.chunkFileNames,
                            assetFileNames: taroConfig.output.assetFileNames,
                            manualChunks(id, { getModuleInfo }) {
                                var _a;
                                const moduleInfo = getModuleInfo(id);
                                const nodeModulesDirRegx = new RegExp(helper_1.REG_NODE_MODULES_DIR);
                                if (nodeModulesDirRegx.test(id) || /commonjsHelpers\.js$/.test(id)) {
                                    return 'vendors';
                                }
                                else if (((_a = moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.importers) === null || _a === void 0 ? void 0 : _a.length) && moduleInfo.importers.length > 1 && !(0, utils_1.isVirtualModule)(id)) {
                                    return 'common';
                                }
                            },
                        }
                    },
                    commonjsOptions: {
                        exclude: [/\.esm/, /[/\\]esm[/\\]/],
                        transformMixedEsModules: true,
                    },
                    assetsInlineLimit: getAssetsInlineLimit(),
                    minify: (0, utils_1.getMinify)(taroConfig),
                    terserOptions: (0, utils_1.getMinify)(taroConfig) === 'terser'
                        ? (0, helper_1.recursiveMerge)({}, constants_1.DEFAULT_TERSER_OPTIONS, ((_d = taroConfig.terser) === null || _d === void 0 ? void 0 : _d.config) || {})
                        : undefined,
                },
                define: getDefineOption(),
                resolve: {
                    mainFields,
                    extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts', '.vue'],
                    alias: getAliasOption(),
                    dedupe: ['@tarojs/shared', '@tarojs/runtime'],
                },
                esbuild: {
                    jsxDev: false,
                },
                server: {
                    host: serverOption.host || '0.0.0.0',
                    port: serverOption.port ? Number(serverOption.port) : 10086,
                    https: typeof serverOption.https !== 'boolean' ? serverOption.https : undefined,
                    open,
                    proxy: serverOption.proxy || {},
                    headers,
                    hmr,
                },
                css: {
                    postcss: {
                        // @Todo Vite 的 postcss 功能不支持 filter 逻辑，Webpack 里的 filter 逻辑需要判断是否仍需要迁移过来 等待 vite pr 合并
                        plugins: (0, utils_1.getPostcssPlugins)(appPath, __postcssOption, constants_1.H5_EXCLUDE_POSTCSS_PLUGIN_NAME),
                        // exclude: postcssExclude
                    },
                    preprocessorOptions: Object.assign(Object.assign({}, (yield getSassOption())), { less: taroConfig.lessLoaderOption || {}, stylus: taroConfig.stylusLoaderOption || {} }),
                    modules: (0, utils_1.getCSSModulesOptions)(taroConfig)
                },
            });
        }),
        transformIndexHtml: {
            enforce: 'pre',
            transform(html) {
                // mpa 模式关于 html 的处理已经解藕到 mpa.ts
                if (isMultiRouterMode)
                    return html;
                const { configPath } = app;
                const scriptSource = configPath.replace(sourceDir, '');
                const htmlScript = (0, html_1.getHtmlScript)(scriptSource, pxtransformOption);
                return html.replace(/<script><%= htmlWebpackPlugin.options.script %><\/script>/, htmlScript);
            },
        },
    };
}
exports.default = default_1;
//# sourceMappingURL=config.js.map