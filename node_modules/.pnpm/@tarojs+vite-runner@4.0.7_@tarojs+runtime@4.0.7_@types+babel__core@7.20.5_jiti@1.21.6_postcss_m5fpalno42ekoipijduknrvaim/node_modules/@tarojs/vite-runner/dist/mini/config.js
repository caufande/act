"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const plugin_babel_1 = require("@rollup/plugin-babel");
const plugin_inject_1 = __importDefault(require("@rollup/plugin-inject"));
const helper_1 = require("@tarojs/helper");
const runner_utils_1 = require("@tarojs/runner-utils");
const shared_1 = require("@tarojs/shared");
const postcss_mini_1 = require("../postcss/postcss.mini");
const utils_1 = require("../utils");
const constants_1 = require("../utils/constants");
const logger_1 = require("../utils/logger");
function default_1(viteCompilerContext) {
    const { taroConfig, cwd: appPath, sourceDir } = viteCompilerContext;
    const isProd = (0, utils_1.getMode)(taroConfig) === 'production';
    function getDefineOption() {
        var _a, _b, _c, _d, _e, _f, _g;
        const { env = {}, runtime = {}, defineConstants = {}, framework = 'react', buildAdapter = helper_1.PLATFORMS.WEAPP, } = taroConfig;
        env.FRAMEWORK = JSON.stringify(framework);
        env.TARO_ENV = JSON.stringify(buildAdapter);
        env.TARO_PLATFORM = JSON.stringify(process.env.TARO_PLATFORM || shared_1.PLATFORM_TYPE.MINI);
        env.NODE_ENV = JSON.stringify(process.env.NODE_ENV);
        env.SUPPORT_TARO_POLYFILL = env.SUPPORT_TARO_POLYFILL || '"disabled"';
        const envConstants = Object.keys(env).reduce((target, key) => {
            target[`process.env.${key}`] = env[key];
            return target;
        }, {});
        const runtimeConstants = {
            ENABLE_INNER_HTML: (_a = runtime.enableInnerHTML) !== null && _a !== void 0 ? _a : true,
            ENABLE_ADJACENT_HTML: (_b = runtime.enableAdjacentHTML) !== null && _b !== void 0 ? _b : false,
            ENABLE_SIZE_APIS: (_c = runtime.enableSizeAPIs) !== null && _c !== void 0 ? _c : false,
            ENABLE_TEMPLATE_CONTENT: (_d = runtime.enableTemplateContent) !== null && _d !== void 0 ? _d : false,
            ENABLE_CLONE_NODE: (_e = runtime.enableCloneNode) !== null && _e !== void 0 ? _e : false,
            ENABLE_CONTAINS: (_f = runtime.enableContains) !== null && _f !== void 0 ? _f : false,
            ENABLE_MUTATION_OBSERVER: (_g = runtime.enableMutationObserver) !== null && _g !== void 0 ? _g : false,
        };
        return Object.assign(Object.assign(Object.assign({}, envConstants), defineConstants), runtimeConstants);
    }
    function getAliasOption() {
        const alias = taroConfig.alias || {};
        return Object.entries(alias).map(([find, replacement]) => {
            return { find, replacement };
        });
    }
    function getInjectOption() {
        var _a;
        const options = {
            window: ['@tarojs/runtime', 'window'],
            document: ['@tarojs/runtime', 'document'],
            navigator: ['@tarojs/runtime', 'navigator'],
            requestAnimationFrame: ['@tarojs/runtime', 'requestAnimationFrame'],
            cancelAnimationFrame: ['@tarojs/runtime', 'cancelAnimationFrame'],
            Element: ['@tarojs/runtime', 'TaroElement'],
            SVGElement: ['@tarojs/runtime', 'SVGElement'],
            MutationObserver: ['@tarojs/runtime', 'MutationObserver'],
            history: ['@tarojs/runtime', 'history'],
            location: ['@tarojs/runtime', 'location'],
            URLSearchParams: ['@tarojs/runtime', 'URLSearchParams'],
            URL: ['@tarojs/runtime', 'URL'],
        };
        const injectOptions = taroConfig.injectOptions;
        if (injectOptions === null || injectOptions === void 0 ? void 0 : injectOptions.include) {
            for (const key in injectOptions.include) {
                options[key] = injectOptions.include[key];
            }
        }
        if ((_a = injectOptions === null || injectOptions === void 0 ? void 0 : injectOptions.exclude) === null || _a === void 0 ? void 0 : _a.length) {
            injectOptions.exclude.forEach((item) => {
                delete options[item];
            });
        }
        return options;
    }
    function getSassOption() {
        return __awaiter(this, void 0, void 0, function* () {
            const sassLoaderOption = taroConfig.sassLoaderOption;
            const nativeStyleImporter = function importer(url, prev, done) {
                // 让 sass 文件里的 @import 能解析小程序原生样式文体，如 @import "a.wxss";
                const extname = node_path_1.default.extname(url);
                // fix: @import 文件可以不带scss/sass缀，如: @import "define";
                if (extname === '.scss' || extname === '.sass' || extname === '.css' || !extname) {
                    return null;
                }
                else {
                    const filePath = node_path_1.default.resolve(node_path_1.default.dirname(prev), url);
                    helper_1.fs.access(filePath, helper_1.fs.constants.F_OK, (err) => {
                        if (err) {
                            logger_1.logger.error(err.message);
                            return null;
                        }
                        else {
                            helper_1.fs.readFile(filePath)
                                .then((res) => {
                                done({ contents: res.toString() });
                            })
                                .catch((err) => {
                                logger_1.logger.error(err);
                                return null;
                            });
                        }
                    });
                }
            };
            const importer = [nativeStyleImporter];
            if (sassLoaderOption === null || sassLoaderOption === void 0 ? void 0 : sassLoaderOption.importer) {
                (0, shared_1.isArray)(sassLoaderOption.importer)
                    ? importer.unshift(...sassLoaderOption.importer)
                    : importer.unshift(sassLoaderOption.importer);
            }
            const option = Object.assign(Object.assign(Object.assign({}, (yield (0, runner_utils_1.getSassLoaderOption)(taroConfig))), sassLoaderOption), { importer });
            return {
                scss: option,
                sass: option,
            };
        });
    }
    const __postcssOption = (0, postcss_mini_1.getDefaultPostcssConfig)({
        designWidth: taroConfig.designWidth || 750,
        deviceRatio: taroConfig.deviceRatio,
        postcssOption: taroConfig.postcss,
    });
    // Note: 分 chunks, commonjs 的循环依赖令人头疼，需要把根据不同的框架，把 taro 和 框架的依赖，打成一个 base chunk（命名为 taro），保证这个 chunk 不会去引用别的 chunk
    function getManualChunks() {
        const { framework } = taroConfig;
        const reactRelatedDeps = [
            /node_modules[\\/]react-reconciler[\\/]/,
            /node_modules[\\/]react[\\/]/,
            /node_modules[\\/]scheduler[\\/]/
        ];
        const vueRelatedDeps = [
            /node_modules[\\/]@vue[\\/]/,
            /node_modules[\\/]vue[\\/]/
        ];
        const taroDeps = [helper_1.REG_TARO_SCOPED_PACKAGE];
        const taroViteRunnerDeps = [/node_modules[\\/]@tarojs[\\/]vite-runner/];
        const nodeModulesDeps = [helper_1.REG_NODE_MODULES_DIR];
        const commonjsHelpersDeps = [/commonjsHelpers\.js$/];
        const tslibDeps = [/node_modules[\\/]tslib[\\/]/];
        const testByReg2DExpList = (reg2DExpList) => (id) => reg2DExpList.some(regExpList => regExpList.some(regExp => regExp.test(id)));
        switch (framework) {
            case 'react':
                return (id, { getModuleInfo }) => {
                    var _a;
                    helper_1.REG_NODE_MODULES_DIR.lastIndex = 0;
                    const moduleInfo = getModuleInfo(id);
                    // Note: vite-runner 里面涉及到一些js文件的注入，比如 comp.js， 为了避免这些文件被打包进 vendors，这里做了特殊处理
                    if (testByReg2DExpList([taroViteRunnerDeps])(id))
                        return null;
                    if (testByReg2DExpList([taroDeps, reactRelatedDeps, tslibDeps, commonjsHelpersDeps])(id))
                        return 'taro';
                    if (testByReg2DExpList([nodeModulesDeps])(id))
                        return 'vendors';
                    if (((_a = moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.importers) === null || _a === void 0 ? void 0 : _a.length) && moduleInfo.importers.length > 1)
                        return 'common';
                };
            case 'vue3':
                return (id, { getModuleInfo }) => {
                    var _a;
                    helper_1.REG_NODE_MODULES_DIR.lastIndex = 0;
                    const moduleInfo = getModuleInfo(id);
                    // Note: vite-runner 里面涉及到一些js文件的注入，比如 comp.js， 为了避免这些文件被打包进 vendors，这里做了特殊处理
                    if (testByReg2DExpList([taroViteRunnerDeps])(id))
                        return null;
                    if (testByReg2DExpList([taroDeps, vueRelatedDeps, tslibDeps, commonjsHelpersDeps])(id))
                        return 'taro';
                    if (testByReg2DExpList([nodeModulesDeps])(id))
                        return 'vendors';
                    if (((_a = moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.importers) === null || _a === void 0 ? void 0 : _a.length) && moduleInfo.importers.length > 1)
                        return 'common';
                };
            default:
                // Note: 其他框架就先不分 chunks 了
                return (id, { getModuleInfo }) => {
                    var _a;
                    helper_1.REG_NODE_MODULES_DIR.lastIndex = 0;
                    const moduleInfo = getModuleInfo(id);
                    // Note: vite-runner 里面涉及到一些js文件的注入，比如 comp.js， 为了避免这些文件被打包进 vendors，这里做了特殊处理
                    if (testByReg2DExpList([taroViteRunnerDeps])(id))
                        return null;
                    if (testByReg2DExpList([nodeModulesDeps, commonjsHelpersDeps])(id))
                        return 'vendors';
                    if (((_a = moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.importers) === null || _a === void 0 ? void 0 : _a.length) && moduleInfo.importers.length > 1)
                        return 'common';
                };
        }
    }
    return {
        name: 'taro:vite-mini-config',
        config: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            return ({
                mode: (0, utils_1.getMode)(taroConfig),
                build: {
                    outDir: node_path_1.default.join(appPath, taroConfig.outputRoot || 'dist'),
                    target: 'es6',
                    cssCodeSplit: true,
                    emptyOutDir: false,
                    lib: {
                        entry: taroConfig.entry.app,
                        formats: ['cjs'],
                    },
                    watch: taroConfig.isWatch ? {} : null,
                    chunkSizeWarningLimit: Number.MAX_SAFE_INTEGER,
                    // @TODO doc needed: sourcemapType not supported
                    sourcemap: (_b = (_a = taroConfig.enableSourceMap) !== null && _a !== void 0 ? _a : taroConfig.isWatch) !== null && _b !== void 0 ? _b : isProd,
                    rollupOptions: {
                        output: {
                            entryFileNames(chunkInfo) {
                                return (0, utils_1.stripMultiPlatformExt)(chunkInfo.name) + taroConfig.fileType.script;
                            },
                            chunkFileNames: taroConfig.output.chunkFileNames,
                            manualChunks: getManualChunks(),
                        },
                        plugins: [
                            (0, plugin_inject_1.default)(getInjectOption()),
                            (0, plugin_babel_1.babel)((0, utils_1.getBabelOption)(taroConfig, {
                                defaultExclude: [/node_modules[/\\](?!@tarojs)/],
                                defaultInclude: [sourceDir, /taro/]
                            })),
                        ],
                    },
                    commonjsOptions: {
                        exclude: [/\.esm/, /[/\\]esm[/\\]/],
                        transformMixedEsModules: true,
                    },
                    minify: (0, utils_1.getMinify)(taroConfig),
                    terserOptions: (0, utils_1.getMinify)(taroConfig) === 'terser'
                        ? (0, helper_1.recursiveMerge)({}, constants_1.DEFAULT_TERSER_OPTIONS, ((_c = taroConfig.terser) === null || _c === void 0 ? void 0 : _c.config) || {})
                        : undefined,
                },
                define: getDefineOption(),
                resolve: {
                    mainFields: [...helper_1.defaultMainFields],
                    extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts', '.vue'],
                    alias: [
                        // 小程序使用 regenerator-runtime@0.11
                        { find: 'regenerator-runtime', replacement: require.resolve('regenerator-runtime') },
                        { find: /@tarojs\/components$/, replacement: taroConfig.taroComponentsPath },
                        ...getAliasOption(),
                    ],
                    dedupe: ['@tarojs/shared', '@tarojs/runtime'],
                },
                esbuild: {
                    jsxDev: false,
                },
                css: {
                    postcss: {
                        plugins: (0, utils_1.getPostcssPlugins)(appPath, __postcssOption, constants_1.MINI_EXCLUDE_POSTCSS_PLUGIN_NAME),
                    },
                    preprocessorOptions: Object.assign(Object.assign({}, (yield getSassOption())), { less: taroConfig.lessLoaderOption || {}, stylus: taroConfig.stylusLoaderOption || {} }),
                    modules: (0, utils_1.getCSSModulesOptions)(taroConfig),
                },
                // @TODO xsscript loader
            });
        }),
        configResolved(_resolvedConfig) {
            // console.log('resolvedConfig.plugins: ', resolvedConfig.plugins)
            // console.log('resolvedConfig.esbuild: ', resolvedConfig.esbuild)
        },
    };
}
exports.default = default_1;
//# sourceMappingURL=config.js.map