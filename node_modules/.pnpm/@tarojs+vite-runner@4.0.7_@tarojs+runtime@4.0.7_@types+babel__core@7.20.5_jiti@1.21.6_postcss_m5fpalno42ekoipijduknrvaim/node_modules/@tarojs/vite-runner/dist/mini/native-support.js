"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.miniTemplateLoader = exports.QUERY_IS_NATIVE_COMP = exports.QUERY_IS_NATIVE_PAGE = void 0;
const node_path_1 = __importDefault(require("node:path"));
const helper_1 = require("@tarojs/helper");
const vite_1 = require("vite");
const utils_1 = require("../utils");
const component_1 = require("../utils/component");
const QUERY_IS_NATIVE_SCRIPT = '?isNativeScript=';
exports.QUERY_IS_NATIVE_PAGE = QUERY_IS_NATIVE_SCRIPT + 'page';
exports.QUERY_IS_NATIVE_COMP = QUERY_IS_NATIVE_SCRIPT + 'comp';
const IS_NATIVE_SCRIPT_REG = new RegExp(`\\${QUERY_IS_NATIVE_SCRIPT}(page|comp)$`);
const QUERY_IS_NATIVE_STYLE = '?isNativeStyle=true';
const IS_NATIVE_STYLE_REG = new RegExp(`\\${QUERY_IS_NATIVE_STYLE}`);
function default_1(viteCompilerContext) {
    // todo 这个插件逻辑不是很清晰 待验证
    const { taroConfig } = viteCompilerContext;
    return {
        name: 'taro:vite-native-support',
        enforce: 'pre',
        buildEnd() {
            viteCompilerContext = undefined;
        },
        resolveId(id) {
            if (!viteCompilerContext)
                return;
            if (IS_NATIVE_STYLE_REG.test(id)) {
                return id;
            }
        },
        load(id) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!viteCompilerContext)
                    return;
                if (IS_NATIVE_SCRIPT_REG.test(id)) {
                    let type = 'page';
                    const target = id.replace(IS_NATIVE_SCRIPT_REG, (_, $1) => {
                        type = $1;
                        return '';
                    });
                    let stylePath = '';
                    if (type === 'page') {
                        for (const page of viteCompilerContext.pages) {
                            if (page.isNative && page.scriptPath === target && page.cssPath && helper_1.fs.existsSync(page.cssPath)) {
                                stylePath = viteCompilerContext.getTargetFilePath(page.cssPath, '.scss');
                                break;
                            }
                        }
                    }
                    else {
                        for (const comp of viteCompilerContext.nativeComponents.values()) {
                            if (comp.scriptPath === target && comp.cssPath && helper_1.fs.existsSync(comp.cssPath)) {
                                stylePath = viteCompilerContext.getTargetFilePath(comp.cssPath, '.scss');
                                break;
                            }
                        }
                    }
                    if (stylePath) {
                        return {
                            code: [
                                `import "${target}";\n`,
                                stylePath ? `import "${stylePath}${QUERY_IS_NATIVE_STYLE}";\n` : ''
                            ].join('')
                        };
                    }
                }
                else if (IS_NATIVE_STYLE_REG.test(id)) {
                    let source = id.replace(new RegExp(`\\${QUERY_IS_NATIVE_STYLE}`), '');
                    source = viteCompilerContext.getTargetFilePath(source, viteCompilerContext.fileType.style);
                    const code = yield helper_1.fs.readFile(source, 'utf-8');
                    return {
                        code
                    };
                }
            });
        },
        moduleParsed({ id, ast }) {
            if (!(0, utils_1.isVirtualModule)(id) && /\.[jt]sx/.test(id)) {
                const walk = require('acorn-walk');
                walk.simple(ast, {
                    CallExpression: node => {
                        var _a;
                        const callee = node.callee;
                        if (callee.type === 'MemberExpression') {
                            if (callee.property.name !== 'createElement') {
                                return;
                            }
                        }
                        else {
                            const nameOfCallee = callee.name;
                            if (
                            // 兼容 react17 new jsx transtrom
                            !(/_?jsxs?/.test(nameOfCallee)) &&
                                // 兼容 Vue 3.0 渲染函数及 JSX
                                !(nameOfCallee === null || nameOfCallee === void 0 ? void 0 : nameOfCallee.includes('createVNode')) &&
                                !(nameOfCallee === null || nameOfCallee === void 0 ? void 0 : nameOfCallee.includes('createBlock')) &&
                                !(nameOfCallee === null || nameOfCallee === void 0 ? void 0 : nameOfCallee.includes('createElementVNode')) &&
                                !(nameOfCallee === null || nameOfCallee === void 0 ? void 0 : nameOfCallee.includes('createElementBlock')) &&
                                !(nameOfCallee === null || nameOfCallee === void 0 ? void 0 : nameOfCallee.includes('resolveComponent')) // 收集使用解析函数的组件名称
                            ) {
                                return;
                            }
                        }
                        const [type, prop] = node.arguments;
                        const componentName = type.name;
                        type.value && ((_a = taroConfig.onParseCreateElement) === null || _a === void 0 ? void 0 : _a.call(taroConfig, type.value, component_1.componentConfig));
                        if (componentName === 'CustomWrapper' && !component_1.componentConfig.thirdPartyComponents.get('custom-wrapper')) {
                            component_1.componentConfig.thirdPartyComponents.set('custom-wrapper', new Set());
                        }
                        if (component_1.componentConfig.thirdPartyComponents.size === 0) {
                            return;
                        }
                        const attrs = component_1.componentConfig.thirdPartyComponents.get(type.value);
                        if (attrs == null || !prop || prop.type !== 'ObjectExpression') {
                            return;
                        }
                        prop.properties
                            .filter(p => p.type === 'Property' && p.key.type === 'Identifier' && p.key.name !== 'children' && p.key.name !== 'id')
                            .forEach(p => attrs.add(p.key.name));
                    }
                });
            }
        },
    };
}
exports.default = default_1;
function miniTemplateLoader(ctx, templatePath, sourceDir) {
    const source = helper_1.fs.readFileSync(templatePath).toString();
    /**
     * 两种fix方案：
     * 1. 用任意xml标签包裹source，使之变成较标准的xml格式（含有一个根节点）
     * 2. 修改 sax.parser 的第一个参数为 true，启用严格模式
     *    2.1 该模式下小程序模板中的标签或属性不会处理（例如写入<Import SrC="..." />不会处理成<import src="..." />，而是保持原样
     *    2.2 该模式将认为传入的xml为非标准的，无需标准化，且不按照以根节点模式处理，因此可以正常解析小程序模板
     *
     * 推荐方案1，这样在构建时会正常打入需要的包，但是若用户有 SrC 类似的写法导致引用失败，则可直接修正，不会认为是打包出现了问题
     **/
    const sourceWithRoot = `<root>${source}</root>`;
    const parser = require('sax').parser(false, { lowercase: true });
    const requests = [];
    parser.onattribute = ({ name, value }) => {
        if (name === 'src' && (0, utils_1.isRelativePath)(value)) {
            const request = node_path_1.default.resolve(node_path_1.default.dirname(templatePath), value);
            requests.push((0, vite_1.normalizePath)(request));
        }
    };
    parser.onend = () => __awaiter(this, void 0, void 0, function* () {
        for (let i = 0; i < requests.length; i++) {
            ctx.emitFile({
                type: 'asset',
                fileName: requests[i].replace(sourceDir, '').replace(/^\//, ''),
                source: yield helper_1.fs.readFile(requests[i])
            });
            ctx.addWatchFile(requests[i]);
        }
    });
    parser.write(sourceWithRoot).close();
    ctx.addWatchFile(templatePath);
    return source;
}
exports.miniTemplateLoader = miniTemplateLoader;
//# sourceMappingURL=native-support.js.map