"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAbsoluteRequire = exports.escapeId = exports.parseRelativePath = exports.escapePath = exports.getBabelOption = exports.getCSSModulesOptions = exports.getMinify = exports.getPostcssPlugins = exports.generateQueryString = exports.getQueryParams = exports.genRouterResource = exports.getMode = exports.stripTrailingSlash = exports.addTrailingSlash = exports.addLeadingSlash = exports.stripMultiPlatformExt = exports.isRelativePath = exports.isVirtualModule = exports.stripVirtualModulePrefix = exports.appendVirtualModulePrefix = exports.virtualModulePrefixREG = exports.getComponentName = exports.prettyPrintJson = exports.convertCopyOptions = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_querystring_1 = __importDefault(require("node:querystring"));
const helper_1 = require("@tarojs/helper");
const shared_1 = require("@tarojs/shared");
const constants_1 = require("./constants");
const createFilter_1 = __importDefault(require("./createFilter"));
const logger_1 = require("./logger");
function convertCopyOptions(taroConfig) {
    const copy = taroConfig.copy;
    const copyOptions = [];
    copy === null || copy === void 0 ? void 0 : copy.patterns.forEach(({ from, to }) => {
        const { base, ext } = node_path_1.default.parse(to);
        to = to
            .replace(new RegExp('^' + taroConfig.outputRoot + '/'), '');
        let rename;
        if (ext) {
            to = to.replace(base, '');
            rename = base;
        }
        else {
            rename = '/';
        }
        copyOptions.push({
            src: from,
            dest: to,
            rename
        });
    });
    return copyOptions;
}
exports.convertCopyOptions = convertCopyOptions;
function prettyPrintJson(obj = {}) {
    return JSON.stringify(obj, null, 2);
}
exports.prettyPrintJson = prettyPrintJson;
function getComponentName(viteCompilerContext, componentPath) {
    let componentName;
    if (helper_1.REG_NODE_MODULES.test(componentPath)) {
        const nodeModulesRegx = new RegExp(helper_1.REG_NODE_MODULES, 'gi');
        componentName = componentPath
            .replace(viteCompilerContext.cwd, '')
            .replace(constants_1.backSlashRegEx, '/')
            .replace(node_path_1.default.extname(componentPath), '')
            .replace(nodeModulesRegx, 'npm');
    }
    else {
        componentName = componentPath
            .replace(viteCompilerContext.sourceDir, '')
            .replace(constants_1.backSlashRegEx, '/')
            .replace(node_path_1.default.extname(componentPath), '');
    }
    return componentName.replace(/^(\/|\\)/, '');
}
exports.getComponentName = getComponentName;
const virtualModulePrefix = '\0';
exports.virtualModulePrefixREG = new RegExp(`^${virtualModulePrefix}`);
function appendVirtualModulePrefix(id) {
    return virtualModulePrefix + id;
}
exports.appendVirtualModulePrefix = appendVirtualModulePrefix;
function stripVirtualModulePrefix(id) {
    return id.replace(exports.virtualModulePrefixREG, '');
}
exports.stripVirtualModulePrefix = stripVirtualModulePrefix;
function isVirtualModule(id) {
    return exports.virtualModulePrefixREG.test(id);
}
exports.isVirtualModule = isVirtualModule;
function isRelativePath(id) {
    if (!(0, shared_1.isString)(id))
        return false;
    if (node_path_1.default.isAbsolute(id))
        return false;
    if (/^[a-z][a-z0-9+.-]*:/i.test(id))
        return false;
    return true;
}
exports.isRelativePath = isRelativePath;
function stripMultiPlatformExt(id) {
    return id.replace(new RegExp(`\\.(${process.env.TARO_ENV}|${process.env.TARO_PLATFORM})$`), '');
}
exports.stripMultiPlatformExt = stripMultiPlatformExt;
const addLeadingSlash = (url = '') => (url.charAt(0) === '/' ? url : '/' + url);
exports.addLeadingSlash = addLeadingSlash;
const addTrailingSlash = (url = '') => (url.charAt(url.length - 1) === '/' ? url : url + '/');
exports.addTrailingSlash = addTrailingSlash;
const stripTrailingSlash = (url = '') => (url.charAt(url.length - 1) === '/' ? url.substring(0, url.length - 1) : url);
exports.stripTrailingSlash = stripTrailingSlash;
function getMode(config) {
    const preMode = config.mode || process.env.NODE_ENV;
    const modes = ['production', 'development', 'none'];
    const mode = modes.find(e => e === preMode) ||
        (!config.isWatch || process.env.NODE_ENV === 'production' ? 'production' : 'development');
    return mode;
}
exports.getMode = getMode;
function genRouterResource(page) {
    return [
        'Object.assign({',
        `  path: '${page.name}',`,
        '  load: async function(context, params) {',
        `    const page = await import("${(0, helper_1.normalizePath)(page.scriptPath)}")`,
        '    return [page, context, params]',
        '  }',
        `}, ${JSON.stringify(page.config)})`
    ].join('\n');
}
exports.genRouterResource = genRouterResource;
function getQueryParams(path) {
    return node_querystring_1.default.parse(path.split('?')[1]);
}
exports.getQueryParams = getQueryParams;
function generateQueryString(params) {
    return node_querystring_1.default.stringify(params);
}
exports.generateQueryString = generateQueryString;
function getPostcssPlugins(appPath, option = {}, excludePluginNames = constants_1.MINI_EXCLUDE_POSTCSS_PLUGIN_NAME) {
    const plugins = [];
    option.forEach(([pluginName, pluginOption, pluginPkg]) => {
        if (!pluginOption || excludePluginNames.includes(pluginName))
            return;
        if (Object.hasOwnProperty.call(pluginOption, 'enable') && !pluginOption.enable)
            return;
        if (pluginPkg) {
            plugins.push(pluginPkg(pluginOption.config || {}));
            return;
        }
        if (!(0, helper_1.isNpmPkg)(pluginName)) {
            // local plugin
            pluginName = node_path_1.default.join(appPath, pluginName);
        }
        try {
            const pluginPath = (0, helper_1.resolveSync)(pluginName, { basedir: appPath }) || '';
            plugins.push(require(pluginPath)(pluginOption.config || {}));
        }
        catch (e) {
            const msg = e.code === 'MODULE_NOT_FOUND' ? `缺少 postcss 插件 "${pluginName}", 已忽略` : e;
            logger_1.logger.info(msg);
        }
    });
    return plugins;
}
exports.getPostcssPlugins = getPostcssPlugins;
function getMinify(taroConfig) {
    var _a, _b, _c;
    const isProd = getMode(taroConfig) === 'production';
    return !isProd
        ? false
        : taroConfig.jsMinimizer === 'esbuild'
            ? ((_b = (_a = taroConfig.esbuild) === null || _a === void 0 ? void 0 : _a.minify) === null || _b === void 0 ? void 0 : _b.enable) === false
                ? false // 只有在明确配置了 esbuild.minify.enable: false 时才不启用压缩
                : 'esbuild'
            : ((_c = taroConfig.terser) === null || _c === void 0 ? void 0 : _c.enable) === false
                ? false // 只有在明确配置了 terser.enable: false 时才不启用压缩
                : 'terser';
}
exports.getMinify = getMinify;
function getCSSModulesOptions(taroConfig) {
    var _a, _b;
    if (((_b = (_a = taroConfig.postcss) === null || _a === void 0 ? void 0 : _a.cssModules) === null || _b === void 0 ? void 0 : _b.enable) !== true)
        return false;
    const config = (0, helper_1.recursiveMerge)({}, {
        namingPattern: 'module',
        generateScopedName: '[name]__[local]___[hash:base64:5]',
    }, taroConfig.postcss.cssModules.config);
    return {
        generateScopedName: config.generateScopedName,
    };
}
exports.getCSSModulesOptions = getCSSModulesOptions;
function getBabelOption(taroConfig, filterConfig = {}) {
    var _a, _b;
    const { compile = {} } = taroConfig;
    const { defaultExclude = [], defaultInclude = [], babelOption } = filterConfig;
    const opts = Object.assign({ extensions: ['.js', '.jsx', '.ts', '.tsx', '.es6', '.es', '.mjs', '.mts'], babelHelpers: 'runtime', skipPreflightCheck: true, compact: false }, babelOption);
    const filter = compile.filter;
    if ((0, shared_1.isFunction)(filter)) {
        opts.filter = filter;
    }
    else {
        let exclude = [];
        let include = [];
        if ((_a = compile.exclude) === null || _a === void 0 ? void 0 : _a.length) {
            const list = compile.exclude;
            const isNodeModuleReseted = list.find((reg) => reg.toString().includes('node_modules'));
            if (!isNodeModuleReseted)
                list.push(...defaultExclude);
            exclude = list;
        }
        else if ((_b = compile.include) === null || _b === void 0 ? void 0 : _b.length) {
            include = [...compile.include, ...defaultInclude];
        }
        else {
            exclude = [...defaultExclude];
        }
        const filter = (0, createFilter_1.default)(include, exclude);
        opts.filter = filter;
    }
    return opts;
}
exports.getBabelOption = getBabelOption;
function escapePath(p) {
    return p.replace(/\\{1,2}/g, '/');
}
exports.escapePath = escapePath;
function parseRelativePath(from, to) {
    const relativePath = escapePath(node_path_1.default.relative(from, to));
    return /^\.{1,2}[\\/]/.test(relativePath)
        ? relativePath
        : /^\.{1,2}$/.test(relativePath)
            ? `${relativePath}/`
            : `./${relativePath}`;
}
exports.parseRelativePath = parseRelativePath;
function escapeId(id) {
    if (!constants_1.needsEscapeRegEx.test(id))
        return id;
    return id.replace(constants_1.backSlashRegEx, '\\\\').replace(constants_1.quoteNewlineRegEx, '\\$1');
}
exports.escapeId = escapeId;
function resolveAbsoluteRequire({ name = '', importer = '', outputRoot = '', targetRoot = '', code = '', resolve, modifyResolveId }) {
    outputRoot = escapePath(outputRoot);
    targetRoot = escapePath(targetRoot);
    return code.replace(/(?:import\s|from\s|require\()['"]([^.][^'"\s]+)['"]\)?/g, (src, source) => {
        var _a;
        importer = stripVirtualModulePrefix(importer);
        const absolutePath = escapePath((0, shared_1.isFunction)(modifyResolveId) ? ((_a = modifyResolveId({
            source,
            importer,
            options: {
                isEntry: false,
                skipSelf: true,
            },
            name,
            resolve,
        })) === null || _a === void 0 ? void 0 : _a.id) || source : source);
        let parsePath = '';
        if (absolutePath.startsWith(outputRoot)) {
            let outputPath = importer;
            if (node_path_1.default.isAbsolute(outputPath)) {
                const commonPath = getCommonPath(targetRoot, importer);
                outputPath = node_path_1.default.relative(commonPath, importer);
            }
            const outputFile = node_path_1.default.resolve(outputRoot, outputPath);
            const outputDir = node_path_1.default.dirname(outputFile);
            parsePath = src.replace(source, parseRelativePath(outputDir, absolutePath));
        }
        else if (absolutePath.startsWith(targetRoot)) {
            parsePath = src.replace(source, parseRelativePath(node_path_1.default.dirname(importer), absolutePath));
        }
        else {
            parsePath = src.replace(source, absolutePath);
        }
        return parsePath;
    });
}
exports.resolveAbsoluteRequire = resolveAbsoluteRequire;
let lastCommonPath = '';
function getCommonPath(a, b) {
    const aArr = node_path_1.default.normalize(a).split(/[\\/]/);
    const bArr = node_path_1.default.normalize(b).split(/[\\/]/);
    let i = 0;
    while (aArr[i] === bArr[i]) {
        i++;
    }
    if (aArr.length > i) {
        // Note: 项目外部文件，仅返回所有外部文件的最短公共路径
        if (!lastCommonPath || lastCommonPath.split(/[\\/]/).length > i) {
            lastCommonPath = aArr.slice(0, i).join('/');
        }
        return lastCommonPath;
    }
    else {
        // Note: 项目内部文件，返回项目根路径
        return a;
    }
}
//# sourceMappingURL=index.js.map