"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompilerContext = void 0;
const node_path_1 = __importDefault(require("node:path"));
const helper_1 = require("@tarojs/helper");
const runner_utils_1 = require("@tarojs/runner-utils");
const utils_1 = require("../../utils");
const logger_1 = require("../logger");
class CompilerContext {
    constructor(appPath, rawTaroConfig) {
        this.logger = logger_1.logger;
        this.filesConfig = {};
        this.configFileList = [];
        this.cwd = appPath;
        this.rawTaroConfig = rawTaroConfig;
        this.process();
    }
    process() {
        this.processConfig();
        this.sourceDir = node_path_1.default.resolve(this.cwd, this.taroConfig.sourceRoot);
        this.frameworkExts = this.taroConfig.frameworkExts || helper_1.SCRIPT_EXT;
    }
    processConfig() { }
    watchConfigFile(rollupCtx) {
        this.configFileList.forEach((configFile) => rollupCtx.addWatchFile(configFile));
    }
    getAppScriptPath() {
        return this.taroConfig.entry.app[0];
    }
    getApp() {
        const scriptPath = this.getAppScriptPath();
        const configPath = this.getConfigFilePath(scriptPath);
        const config = (0, helper_1.readConfig)(configPath, this.taroConfig);
        if ((0, helper_1.isEmptyObject)(config)) {
            this.logger.error('缺少 app 全局配置文件，请检查！');
            process.exit(1);
        }
        const appMeta = {
            name: node_path_1.default.basename(scriptPath).replace(node_path_1.default.extname(scriptPath), ''),
            scriptPath,
            configPath,
            config,
            isNative: false
        };
        this.filesConfig[this.getConfigFilePath(appMeta.name)] = {
            path: configPath,
            content: config
        };
        return appMeta;
    }
    getPages() {
        var _a;
        const appConfig = this.app.config;
        if (this.taroConfig.isBuildNativeComp)
            return [];
        if (!((_a = appConfig.pages) === null || _a === void 0 ? void 0 : _a.length)) {
            this.logger.error('全局配置缺少 pages 字段，请检查！');
            process.exit(1);
        }
        const pagesList = appConfig.pages.map(pageName => this.compilePage(pageName));
        const subPackages = appConfig.subPackages || appConfig.subpackages || [];
        subPackages.forEach(item => {
            // 兼容 pages: [''] 等非法情况
            const pages = (item.pages || []).filter(item => !!item);
            if (pages.length > 0) {
                const root = item.root;
                pages.forEach(page => {
                    const subPageName = `${root}/${page}`.replace(/\/{2,}/g, '/');
                    for (const mainPage of pagesList) {
                        if (mainPage.name === subPageName)
                            return;
                    }
                    const pageMeta = this.compilePage(subPageName);
                    pagesList.push(pageMeta);
                });
            }
        });
        return pagesList;
    }
    getComponents() {
        var _a;
        const appConfig = this.app.config;
        if (!((_a = appConfig.components) === null || _a === void 0 ? void 0 : _a.length)) {
            this.logger.error('全局配置缺少 components 字段，请检查！');
            process.exit(1);
        }
        return appConfig.components.map(pageName => this.compilePage(pageName));
    }
    /** 工具函数 */
    isApp(id) {
        return this.app.scriptPath === id;
    }
    isPage(id) {
        return this.pages.findIndex(page => page.scriptPath === id) > -1;
    }
    isComponent(id) {
        if (this.components && this.components.length) {
            return this.components.findIndex(component => component.scriptPath === id) > -1;
        }
        return false;
    }
    isNativePageORComponent(templatePath) {
        return helper_1.fs.existsSync(templatePath);
    }
    getPageById(id) {
        return this.pages.find(page => page.scriptPath === id);
    }
    getComponentById(id) {
        if (this.components && this.components.length) {
            return this.components.find(component => component.scriptPath === id);
        }
    }
    getConfigFilePath(filePath) {
        const cleanedPath = (0, utils_1.stripMultiPlatformExt)(filePath.replace(node_path_1.default.extname(filePath), ''));
        return (0, helper_1.resolveMainFilePath)(`${cleanedPath}.config`);
    }
    getTargetFilePath(filePath, targetExtName) {
        const extname = node_path_1.default.extname(filePath);
        return extname
            ? filePath.replace(extname, targetExtName)
            : filePath + targetExtName;
    }
}
exports.CompilerContext = CompilerContext;
CompilerContext.label = runner_utils_1.VITE_COMPILER_LABEL;
//# sourceMappingURL=base.js.map