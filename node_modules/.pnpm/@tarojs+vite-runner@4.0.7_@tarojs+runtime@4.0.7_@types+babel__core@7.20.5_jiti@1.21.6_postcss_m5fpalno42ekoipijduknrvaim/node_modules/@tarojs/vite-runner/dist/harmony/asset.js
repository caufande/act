"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileToUrl = exports.publicFileToBuiltUrl = exports.checkPublicFile = exports.assetPlugin = exports.renderAssetUrlInJS = exports.publicAssetUrlCache = exports.generatedAssets = exports.assetUrlRE = void 0;
const node_path_1 = __importDefault(require("node:path"));
const helper_1 = require("@tarojs/helper");
const magic_string_1 = __importDefault(require("magic-string"));
const mrmime = __importStar(require("mrmime"));
const vite_1 = require("vite");
const utils_1 = require("../utils");
const build_1 = require("./postcss/build");
const constants_1 = require("./postcss/constants");
const utils_2 = require("./postcss/utils");
exports.assetUrlRE = /__TARO_VITE_ASSET__([a-z\d]+)__(?:\$_(.*?)__)?/g;
const rawRE = /(?:\?|&)raw(?:&|$)/;
const urlRE = /(\?|&)url(?:&|$)/;
const unnededFinalQueryCharRE = /[?&]$/;
const assetCache = new WeakMap();
exports.generatedAssets = new WeakMap();
exports.publicAssetUrlCache = new WeakMap();
// add own dictionary entry by directly assigning mrmime
function registerCustomMime() {
    // https://github.com/lukeed/mrmime/issues/3
    mrmime.mimes.ico = 'image/x-icon';
    // https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers#flac
    mrmime.mimes.flac = 'audio/flac';
    // mrmime and mime-db is not released yet: https://github.com/jshttp/mime-db/commit/c9242a9b7d4bb25d7a0c9244adec74aeef08d8a1
    mrmime.mimes.aac = 'audio/aac';
    // https://wiki.xiph.org/MIME_Types_and_File_Extensions#.opus_-_audio/ogg
    mrmime.mimes.opus = 'audio/ogg';
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
    mrmime.mimes.eot = 'application/vnd.ms-fontobject';
}
function renderAssetUrlInJS(ctx, config, chunk, opts, code) {
    const toRelativeRuntime = (0, build_1.createToImportMetaURLBasedRelativeRuntime)(opts.format, config.isWorker);
    let match;
    let s;
    // Urls added with JS using e.g.
    // imgElement.src = "__TARO_VITE_ASSET__5aa0ddc0__" are using quotes
    // Urls added in CSS that is imported in JS end up like
    // var inlined = ".inlined{color:green;background:url(__TARO_VITE_ASSET__5aa0ddc0__)}\n";
    // In both cases, the wrapping should already be fine
    exports.assetUrlRE.lastIndex = 0;
    while ((match = exports.assetUrlRE.exec(code))) {
        s || (s = new magic_string_1.default(code));
        const [full, referenceId, postfix = ''] = match;
        const file = ctx.getFileName(referenceId);
        const filename = file + postfix;
        const replacement = (0, build_1.toOutputFilePathInJS)(filename, 'asset', chunk.fileName, 'js', config, toRelativeRuntime);
        const replacementString = typeof replacement === 'string'
            ? JSON.stringify(replacement).slice(1, -1)
            : `"+${replacement.runtime}+"`;
        s.update(match.index, match.index + full.length, replacementString);
    }
    // Replace __TARO_VITE_PUBLIC_ASSET__5aa0ddc0__ with absolute paths
    const publicAssetUrlMap = exports.publicAssetUrlCache.get(config);
    constants_1.publicAssetUrlRE.lastIndex = 0;
    while ((match = constants_1.publicAssetUrlRE.exec(code))) {
        s || (s = new magic_string_1.default(code));
        const [full, hash] = match;
        const publicUrl = publicAssetUrlMap.get(hash).slice(1);
        const replacement = (0, build_1.toOutputFilePathInJS)(publicUrl, 'public', chunk.fileName, 'js', config, toRelativeRuntime);
        const replacementString = typeof replacement === 'string'
            ? JSON.stringify(replacement).slice(1, -1)
            : `"+${replacement.runtime}+"`;
        s.update(match.index, match.index + full.length, replacementString);
    }
    return s;
}
exports.renderAssetUrlInJS = renderAssetUrlInJS;
/**
 * Also supports loading plain strings with import text from './foo.txt?raw'
 */
function assetPlugin(viteCompilerContext) {
    registerCustomMime();
    let viteConfig;
    return {
        name: 'taro:vite-asset',
        enforce: 'pre',
        configResolved(config) {
            viteConfig = config;
        },
        buildStart() {
            assetCache.set(viteConfig, new Map());
            exports.generatedAssets.set(viteConfig, new Map());
        },
        resolveId(id) {
            if (!viteConfig.assetsInclude((0, utils_2.cleanUrl)(id)) && !urlRE.test(id)) {
                return;
            }
            // imports to absolute urls pointing to files in /public
            // will fail to resolve in the main resolver. handle them here.
            const publicFile = checkPublicFile(id, viteConfig);
            if (publicFile) {
                return id;
            }
        },
        load(id) {
            if (utils_1.virtualModulePrefixREG.test(id)) {
                // Rollup convention, this id should be handled by the
                // plugin that marked it with \0
                return;
            }
            // raw requests, read from disk
            if (rawRE.test(id)) {
                const file = checkPublicFile(id, viteConfig) || (0, utils_2.cleanUrl)(id);
                // raw query, read file and return as string
                return `export default ${JSON.stringify(helper_1.fs.readFileSync(file, 'utf-8'))}`;
            }
            if (!viteConfig.assetsInclude((0, utils_2.cleanUrl)(id)) && !urlRE.test(id)) {
                return;
            }
            id = id.replace(urlRE, '$1').replace(unnededFinalQueryCharRE, '');
            const url = fileToUrl(id, viteConfig, this, viteCompilerContext);
            return `export default ${JSON.stringify(url)}`;
        },
        renderChunk(code, chunk, opts) {
            const s = renderAssetUrlInJS(this, viteConfig, chunk, opts, code);
            if (s) {
                return {
                    code: s.toString(),
                    map: viteConfig.build.sourcemap
                        ? s.generateMap({ hires: 'boundary' })
                        : null,
                };
            }
            else {
                return null;
            }
        },
    };
}
exports.assetPlugin = assetPlugin;
function checkPublicFile(url, { publicDir }) {
    // note if the file is in /public, the resolver would have returned it
    // as-is so it's not going to be a fully resolved path.
    if (!publicDir || url[0] !== '/') {
        return;
    }
    const publicFile = node_path_1.default.join(publicDir, (0, utils_2.cleanUrl)(url));
    if (!(0, vite_1.normalizePath)(publicFile).startsWith((0, utils_1.addTrailingSlash)((0, vite_1.normalizePath)(publicDir)))) {
        // can happen if URL starts with '../'
        return;
    }
    if (helper_1.fs.existsSync(publicFile)) {
        return publicFile;
    }
}
exports.checkPublicFile = checkPublicFile;
function publicFileToBuiltUrl(url, config) {
    const hash = (0, helper_1.getHash)(url);
    let cache = exports.publicAssetUrlCache.get(config);
    if (!cache) {
        cache = new Map();
        exports.publicAssetUrlCache.set(config, cache);
    }
    if (!cache.get(hash)) {
        cache.set(hash, url);
    }
    return `__TARO_VITE_PUBLIC_ASSET__${hash}__`;
}
exports.publicFileToBuiltUrl = publicFileToBuiltUrl;
function fileToUrl(id, config, _pluginContext, viteCompilerContext, skipPublicCheck = false) {
    if (!skipPublicCheck && checkPublicFile(id, config)) {
        return publicFileToBuiltUrl(id, config);
    }
    const cache = assetCache.get(config);
    const cached = cache.get(id);
    if (cached) {
        return cached;
    }
    const file = (0, utils_2.cleanUrl)(id);
    const content = helper_1.fs.readFileSync(file);
    // emit as asset
    // const { search, hash } = parseUrl(id)
    // const postfix = (search || '') + (hash || '')
    const { cwd: appPath, taroConfig } = viteCompilerContext;
    const { sourceRoot = 'src', outputRoot = 'dist' } = taroConfig;
    const appRoot = node_path_1.default.resolve(appPath, sourceRoot);
    // const referenceId = pluginContext.emitFile({
    //   // Ignore directory structure for asset file names
    //   fileName: path.relative(appRoot, file),
    //   name: path.basename(file),
    //   type: 'asset',
    //   source: content,
    // })
    // const originalName = normalizePath(path.relative(config.root, file))
    // generatedAssets.get(config)!.set(referenceId, { originalName })
    // const url = `__TARO_VITE_ASSET__${referenceId}__${postfix ? `$_${postfix}__` : ``}` // TODO_BASE
    const resourceName = node_path_1.default.relative(appRoot, file).replace(/^[\\/]+/, '').replace(/[\\/-]+/g, '_');
    const resourcePath = node_path_1.default.join(process.cwd(), outputRoot, '..', 'resources/base/media', resourceName);
    helper_1.fs.ensureDirSync(node_path_1.default.dirname(resourcePath));
    helper_1.fs.writeFileSync(resourcePath, content, {
        encoding: 'utf-8',
    });
    cache.set(id, resourcePath);
    return 'resource://base/media/' + resourceName;
}
exports.fileToUrl = fileToUrl;
//# sourceMappingURL=asset.js.map