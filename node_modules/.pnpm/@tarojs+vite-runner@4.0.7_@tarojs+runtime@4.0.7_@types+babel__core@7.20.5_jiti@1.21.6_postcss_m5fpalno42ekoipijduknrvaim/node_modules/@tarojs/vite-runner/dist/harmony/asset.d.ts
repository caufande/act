import MagicString from 'magic-string';
import type { ViteHarmonyCompilerContext } from '@tarojs/taro/types/compile/viteCompilerContext';
import type { NormalizedOutputOptions, PluginContext, RenderedChunk } from 'rollup';
import type { Plugin, ResolvedConfig } from 'vite';
export declare const assetUrlRE: RegExp;
interface GeneratedAssetMeta {
    originalName: string;
    isEntry?: boolean;
}
export declare const generatedAssets: WeakMap<Readonly<Omit<import("vite").UserConfig, "plugins" | "css" | "assetsInclude" | "optimizeDeps" | "worker" | "build"> & {
    configFile: string | undefined;
    configFileDependencies: string[];
    inlineConfig: import("vite").InlineConfig;
    root: string;
    base: string;
    publicDir: string;
    cacheDir: string;
    command: "build" | "serve";
    mode: string;
    isWorker: boolean;
    isProduction: boolean;
    envDir: string;
    env: Record<string, any>;
    resolve: Required<import("vite").ResolveOptions> & {
        alias: import("vite").Alias[];
    };
    plugins: readonly Plugin[];
    css: import("vite").ResolvedCSSOptions | undefined;
    esbuild: false | import("vite").ESBuildOptions;
    server: import("vite").ResolvedServerOptions;
    build: import("vite").ResolvedBuildOptions;
    preview: import("vite").ResolvedPreviewOptions;
    ssr: import("vite").ResolvedSSROptions;
    assetsInclude: (file: string) => boolean;
    logger: import("vite").Logger;
    createResolver: (options?: Partial<import("vite").InternalResolveOptions> | undefined) => import("vite").ResolveFn;
    optimizeDeps: import("vite").DepOptimizationOptions;
    worker: import("vite").ResolveWorkerOptions;
    appType: import("vite").AppType;
    experimental: import("vite").ExperimentalOptions;
} & import("vite").PluginHookUtils>, Map<string, GeneratedAssetMeta>>;
export declare const publicAssetUrlCache: WeakMap<Readonly<Omit<import("vite").UserConfig, "plugins" | "css" | "assetsInclude" | "optimizeDeps" | "worker" | "build"> & {
    configFile: string | undefined;
    configFileDependencies: string[];
    inlineConfig: import("vite").InlineConfig;
    root: string;
    base: string;
    publicDir: string;
    cacheDir: string;
    command: "build" | "serve";
    mode: string;
    isWorker: boolean;
    isProduction: boolean;
    envDir: string;
    env: Record<string, any>;
    resolve: Required<import("vite").ResolveOptions> & {
        alias: import("vite").Alias[];
    };
    plugins: readonly Plugin[];
    css: import("vite").ResolvedCSSOptions | undefined;
    esbuild: false | import("vite").ESBuildOptions;
    server: import("vite").ResolvedServerOptions;
    build: import("vite").ResolvedBuildOptions;
    preview: import("vite").ResolvedPreviewOptions;
    ssr: import("vite").ResolvedSSROptions;
    assetsInclude: (file: string) => boolean;
    logger: import("vite").Logger;
    createResolver: (options?: Partial<import("vite").InternalResolveOptions> | undefined) => import("vite").ResolveFn;
    optimizeDeps: import("vite").DepOptimizationOptions;
    worker: import("vite").ResolveWorkerOptions;
    appType: import("vite").AppType;
    experimental: import("vite").ExperimentalOptions;
} & import("vite").PluginHookUtils>, Map<string, string>>;
export declare function renderAssetUrlInJS(ctx: PluginContext, config: ResolvedConfig, chunk: RenderedChunk, opts: NormalizedOutputOptions, code: string): MagicString | undefined;
/**
 * Also supports loading plain strings with import text from './foo.txt?raw'
 */
export declare function assetPlugin(viteCompilerContext: ViteHarmonyCompilerContext): Plugin;
export declare function checkPublicFile(url: string, { publicDir }: ResolvedConfig): string | undefined;
export declare function publicFileToBuiltUrl(url: string, config: ResolvedConfig): string;
export declare function fileToUrl(id: string, config: ResolvedConfig, _pluginContext: PluginContext, viteCompilerContext: ViteHarmonyCompilerContext, skipPublicCheck?: boolean): string;
export {};
