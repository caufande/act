"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const plugin_babel_1 = require("@rollup/plugin-babel");
const plugin_inject_1 = __importDefault(require("@rollup/plugin-inject"));
const plugin_terser_1 = __importDefault(require("@rollup/plugin-terser"));
const helper_1 = require("@tarojs/helper");
const runner_utils_1 = require("@tarojs/runner-utils");
const shared_1 = require("@tarojs/shared");
const rollup_increment_plugin_1 = __importDefault(require("../common/rollup-increment-plugin"));
const postcss_harmony_1 = require("../postcss/postcss.harmony");
const utils_1 = require("../utils");
const constants_1 = require("../utils/constants");
const logger_1 = require("../utils/logger");
const entry_1 = require("./entry");
const ets_1 = require("./ets");
const page_1 = require("./page");
function default_1(viteCompilerContext) {
    const { taroConfig, cwd: appPath } = viteCompilerContext;
    function getDefineOption() {
        const { buildAdapter = helper_1.PLATFORMS.HARMONY, env = {}, defineConstants = {}, framework = 'react', } = taroConfig;
        env.FRAMEWORK = JSON.stringify(framework);
        env.TARO_ENV = JSON.stringify(buildAdapter);
        env.TARO_PLATFORM = JSON.stringify(process.env.TARO_PLATFORM || env.TARO_PLATFORM || shared_1.PLATFORM_TYPE.HARMONY);
        env.TARO_VERSION = JSON.stringify(process.env.TARO_VERSION || env.TARO_VERSION);
        env.NODE_ENV = JSON.stringify(process.env.NODE_ENV || env.NODE_ENV || 'development');
        env.SUPPORT_TARO_POLYFILL = env.SUPPORT_TARO_POLYFILL || '"disabled"';
        const envConstants = Object.keys(env).reduce((target, key) => {
            target[`process.env.${key}`] = env[key];
            return target;
        }, {});
        return Object.assign(Object.assign({}, envConstants), defineConstants);
    }
    function getAliasOption() {
        const { alias = {} } = taroConfig;
        return Object.entries(alias).map(([find, replacement]) => {
            return { find, replacement };
        });
    }
    function getNativeComponentEntry() {
        const nativeCompPathList = [];
        for (const comp of viteCompilerContext.nativeComponents.values()) {
            if (comp.isPackage)
                continue;
            nativeCompPathList.push(comp.templatePath + ets_1.QUERY_IS_NATIVE_SCRIPT);
        }
        return nativeCompPathList;
    }
    function getEntryOption() {
        const { isBuildNativeComp, blended } = taroConfig;
        if (isBuildNativeComp) {
            return viteCompilerContext.components.map(page => page.scriptPath).concat(getNativeComponentEntry());
        }
        else if (blended) {
            return viteCompilerContext.pages.map(page => {
                if (page.isNative) {
                    const { sourceDir, nativeExt } = viteCompilerContext;
                    const nativePath = (0, helper_1.resolveMainFilePath)(node_path_1.default.join(sourceDir, page.name), nativeExt);
                    return nativePath + ets_1.QUERY_IS_NATIVE_SCRIPT;
                }
                else {
                    return page.scriptPath;
                }
            }).concat(getNativeComponentEntry());
        }
        return taroConfig.entry.app;
    }
    function getInjectOption() {
        var _a;
        const options = {
            window: ['@tarojs/runtime', 'window'],
            document: ['@tarojs/runtime', 'document'],
            navigator: ['@tarojs/runtime', 'navigator'],
            requestAnimationFrame: ['@tarojs/runtime', 'requestAnimationFrame'],
            cancelAnimationFrame: ['@tarojs/runtime', 'cancelAnimationFrame'],
            Element: ['@tarojs/runtime', 'TaroElement'],
            SVGElement: ['@tarojs/runtime', 'SVGElement'],
            MutationObserver: ['@tarojs/runtime', 'MutationObserver'],
            history: ['@tarojs/runtime', 'history'],
            location: ['@tarojs/runtime', 'location'],
            URLSearchParams: ['@tarojs/runtime', 'URLSearchParams'],
            getComputedStyle: ['@tarojs/runtime', 'getComputedStyle'],
            URL: ['@tarojs/runtime', 'URL'],
            wx: ['@tarojs/taro', '*'],
            getCurrentPages: ['@tarojs/taro', 'getCurrentPages'],
            IntersectionObserver: ['@tarojs/taro', 'IntersectionObserver']
        };
        const injectOptions = taroConfig.injectOptions;
        if (injectOptions === null || injectOptions === void 0 ? void 0 : injectOptions.include) {
            for (const key in injectOptions.include) {
                options[key] = injectOptions.include[key];
            }
        }
        if ((_a = injectOptions === null || injectOptions === void 0 ? void 0 : injectOptions.exclude) === null || _a === void 0 ? void 0 : _a.length) {
            injectOptions.exclude.forEach((item) => {
                delete options[item];
            });
        }
        return options;
    }
    const __postcssOption = (0, postcss_harmony_1.getDefaultPostcssConfig)({
        designWidth: taroConfig.designWidth || 750,
        deviceRatio: taroConfig.deviceRatio,
        postcssOption: taroConfig.postcss,
    });
    function getSassOption() {
        return __awaiter(this, void 0, void 0, function* () {
            const sassLoaderOption = taroConfig.sassLoaderOption;
            const nativeStyleImporter = function importer(url, prev, done) {
                // 让 sass 文件里的 @import 能解析小程序原生样式文体，如 @import "a.wxss";
                const extname = node_path_1.default.extname(url);
                // fix: @import 文件可以不带scss/sass缀，如: @import "define";
                if (extname === '.scss' || extname === '.sass' || extname === '.css' || !extname) {
                    return null;
                }
                else {
                    const filePath = node_path_1.default.resolve(node_path_1.default.dirname(prev), url);
                    helper_1.fs.access(filePath, helper_1.fs.constants.F_OK, (err) => {
                        if (err) {
                            logger_1.logger.error(err.message);
                            return null;
                        }
                        else {
                            helper_1.fs.readFile(filePath)
                                .then((res) => {
                                done({ contents: res.toString() });
                            })
                                .catch((err) => {
                                logger_1.logger.error(err);
                                return null;
                            });
                        }
                    });
                }
            };
            const importer = [nativeStyleImporter];
            if (sassLoaderOption === null || sassLoaderOption === void 0 ? void 0 : sassLoaderOption.importer) {
                (0, shared_1.isArray)(sassLoaderOption.importer)
                    ? importer.unshift(...sassLoaderOption.importer)
                    : importer.unshift(sassLoaderOption.importer);
            }
            const option = Object.assign(Object.assign(Object.assign({}, (yield (0, runner_utils_1.getSassLoaderOption)(taroConfig))), sassLoaderOption), { importer });
            return {
                scss: option,
                sass: option,
            };
        });
    }
    return {
        name: 'taro:vite-harmony-config',
        options(opt) {
            if (opt.plugins instanceof Array) {
                // Note: 移除冗余的 babel 插件，改用 runner 提供的版本
                const idx = opt.plugins.findIndex(e => e && e.name === 'vite:react-babel');
                if (idx >= 0)
                    opt.plugins.splice(idx, 1);
            }
        },
        config: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const output = {
                entryFileNames(chunkInfo) {
                    var _a;
                    let name;
                    if (taroConfig.isBuildNativeComp || taroConfig.blended) {
                        const pagePath = node_path_1.default.relative(taroConfig.sourceRoot || 'src', node_path_1.default.dirname((0, utils_1.stripVirtualModulePrefix)(chunkInfo.facadeModuleId || '')));
                        if (chunkInfo.name.includes(pagePath)) {
                            name = chunkInfo.name;
                        }
                        else {
                            name = node_path_1.default.join(pagePath, chunkInfo.name);
                        }
                    }
                    else {
                        name = chunkInfo.name;
                    }
                    name = name.replace(/[\\/]+/g, '/');
                    const appId = viteCompilerContext.app.config.appId || 'app';
                    const isTaroComp = appId === name ||
                        viteCompilerContext.pages.some((page) => [page.name, page.originName].includes(name)) ||
                        ((_a = viteCompilerContext.components) === null || _a === void 0 ? void 0 : _a.some((comp) => [comp.name, comp.originName].includes(name)));
                    // 如果同时存在app.ets和app.js，因为鸿蒙IDE编译会把app.ets编译成app.ts，会跟app.js冲突，识别都是/app，导致app.js被app.ts覆盖了，所以需要名字
                    const suffix = isTaroComp ? utils_1.virtualModulePrefixREG.test(chunkInfo.facadeModuleId || '') ? entry_1.TARO_COMP_SUFFIX : '_comp' : '';
                    name = (0, utils_1.stripMultiPlatformExt)(`${name}${suffix}`) + taroConfig.fileType.script;
                    if (chunkInfo.facadeModuleId && chunkInfo.facadeModuleId.includes(ets_1.QUERY_IS_NATIVE_SCRIPT)) {
                        name += ets_1.QUERY_IS_NATIVE_SCRIPT;
                    }
                    if (name.startsWith('.')) {
                        name = name.replace(/^\.[.\\/]+/, '');
                    }
                    return name;
                },
                chunkFileNames(chunkInfo) {
                    var _a;
                    if ((_a = chunkInfo.moduleIds) === null || _a === void 0 ? void 0 : _a.some(id => id.includes(taroConfig.fileType.script))) {
                        return `[name]${taroConfig.fileType.script}`;
                    }
                    return '[name].js';
                },
                manualChunks(id, { getModuleInfo }) {
                    var _a;
                    if (taroConfig.isBuildNativeComp || taroConfig.blended)
                        return;
                    const moduleInfo = getModuleInfo(id);
                    const nodeModulesDirRegx = new RegExp(helper_1.REG_NODE_MODULES_DIR);
                    if (nodeModulesDirRegx.test(id) || /commonjsHelpers\.js$/.test(id)) {
                        return 'vendors';
                    }
                    else if (((_a = moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.importers) === null || _a === void 0 ? void 0 : _a.length) && moduleInfo.importers.length > 1 && !(0, utils_1.isVirtualModule)(id)) {
                        return 'common';
                    }
                },
            };
            if (taroConfig.isWatch && !taroConfig.blended) {
                delete output.manualChunks;
                output.preserveModules = true;
                output.preserveModulesRoot = 'src';
                output.minifyInternalExports = false;
                // Note: 修复虚拟模块的依赖和引用，使其能够正确的输出
                output.sanitizeFileName = (filename) => filename.replace(/^_virtual[\\/]/, '').replace(/[\0?*]/g, '_');
            }
            const rollupPlugins = [
                (0, plugin_inject_1.default)(getInjectOption()),
                (0, plugin_babel_1.babel)((0, utils_1.getBabelOption)(taroConfig, {
                    babelOption: {
                        extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts', '.es6', '.es', '.ets'],
                    },
                })),
                (0, rollup_increment_plugin_1.default)({
                    force: (id) => /app\.config/.test(id),
                    comparisonId: (id = '', files) => {
                        const nodeModulesDirRegx = new RegExp(helper_1.REG_NODE_MODULES_DIR);
                        if (nodeModulesDirRegx.test(id))
                            return false;
                        const rawId = (0, utils_1.stripVirtualModulePrefix)(id).replace(page_1.PAGE_SUFFIX, '');
                        const etx = node_path_1.default.extname(rawId);
                        id = etx ? rawId.replace(new RegExp(`${etx}$`), '') : rawId;
                        const list = Array.from(files);
                        const rgx = new RegExp(`^${id}\\.config`);
                        return list.some(file => rgx.test(file));
                    },
                }),
            ];
            // Note: Vite 官方插件禁用了 es 输出模式下的 terser 插件，这里需要手动添加
            if (!taroConfig.isWatch && (0, utils_1.getMinify)(taroConfig) === 'terser') {
                rollupPlugins.push((0, plugin_terser_1.default)((0, helper_1.recursiveMerge)({}, constants_1.DEFAULT_TERSER_OPTIONS, ((_a = taroConfig.terser) === null || _a === void 0 ? void 0 : _a.config) || {})));
            }
            return {
                mode: (0, utils_1.getMode)(taroConfig),
                build: {
                    outDir: taroConfig.outputRoot || 'dist',
                    target: 'esnext',
                    cssCodeSplit: true,
                    emptyOutDir: false,
                    lib: {
                        entry: getEntryOption(),
                        formats: ['es'],
                    },
                    watch: taroConfig.isWatch ? {} : null,
                    // TODO doc needed: sourcemapType not supported
                    sourcemap: (_c = (_b = taroConfig.enableSourceMap) !== null && _b !== void 0 ? _b : taroConfig.isWatch) !== null && _c !== void 0 ? _c : process.env.NODE_ENV !== 'production',
                    rollupOptions: {
                        treeshake: !taroConfig.isWatch,
                        external: constants_1.HARMONY_SCOPES,
                        makeAbsoluteExternalsRelative: 'ifRelativeSource',
                        output: output,
                        plugins: rollupPlugins,
                    },
                    commonjsOptions: {
                        // TODO: 优化过滤
                        extensions: ['.js', '.ts'],
                        transformMixedEsModules: true,
                    },
                    minify: (0, utils_1.getMinify)(taroConfig),
                    terserOptions: (0, utils_1.getMinify)(taroConfig) === 'terser'
                        ? (0, helper_1.recursiveMerge)({}, constants_1.DEFAULT_TERSER_OPTIONS, ((_d = taroConfig.terser) === null || _d === void 0 ? void 0 : _d.config) || {})
                        : undefined,
                },
                define: getDefineOption(),
                resolve: {
                    mainFields: [...helper_1.defaultMainFields],
                    extensions: ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts', '.vue', '.ets'],
                    alias: [
                        ...getAliasOption(),
                    ],
                    dedupe: ['@tarojs/shared', '@tarojs/runtime'],
                },
                esbuild: {
                    jsxDev: false,
                },
                css: {
                    postcss: {
                        plugins: (0, utils_1.getPostcssPlugins)(appPath, __postcssOption),
                    },
                    preprocessorOptions: Object.assign({}, (yield getSassOption())),
                    modules: (0, utils_1.getCSSModulesOptions)(taroConfig),
                },
            };
        }),
    };
}
exports.default = default_1;
//# sourceMappingURL=config.js.map