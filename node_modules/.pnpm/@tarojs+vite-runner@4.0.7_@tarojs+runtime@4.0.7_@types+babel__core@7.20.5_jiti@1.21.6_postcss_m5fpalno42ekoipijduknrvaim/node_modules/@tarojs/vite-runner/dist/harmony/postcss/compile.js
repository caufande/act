"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileCSS = void 0;
const node_path_1 = __importDefault(require("node:path"));
const helper_1 = require("@tarojs/helper");
const fast_glob_1 = __importDefault(require("fast-glob"));
const vite_1 = require("vite");
const asset_1 = require("../asset");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const resolve_1 = require("./resolve");
const resolvers_1 = require("./resolvers");
const url_1 = require("./url");
const utils_1 = require("./utils");
const preProcessors = Object.freeze({
    ["less" /* PreprocessLang.less */]: resolvers_1.less,
    ["sass" /* PreprocessLang.sass */]: resolvers_1.sass,
    ["scss" /* PreprocessLang.scss */]: resolvers_1.scss,
    ["styl" /* PreprocessLang.styl */]: resolvers_1.styl,
    ["stylus" /* PreprocessLang.stylus */]: resolvers_1.styl,
});
function compileCSS(id, code, config, urlReplacer, isGlobalModule) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const { modules: modulesOptions, preprocessorOptions, devSourcemap, } = config.css || {};
        const cssModuleRegex = isGlobalModule ? constants_2.cssGlobalModuleRE : constants_2.cssModuleRE;
        const isModule = modulesOptions !== false && cssModuleRegex.test(id);
        // although at serve time it can work without processing, we do need to
        // crawl them in order to register watch dependencies.
        const needInlineImport = code.includes('@import');
        const hasUrl = constants_2.cssUrlRE.test(code) || constants_2.cssImageSetRE.test(code);
        const lang = (_a = id.match(constants_1.CSS_LANGS_RE)) === null || _a === void 0 ? void 0 : _a[1];
        const postcssConfig = yield (0, resolve_1.resolvePostcssConfig)(config, getCssDialect(lang));
        // 1. plain css that needs no processing
        if (lang === 'css' &&
            !postcssConfig &&
            !isModule &&
            !needInlineImport &&
            !hasUrl) {
            return { code, map: null };
        }
        let preprocessorMap;
        let modules;
        const deps = new Set();
        let atImportResolvers = resolvers_1.configToAtImportResolvers.get(config);
        if (!atImportResolvers) {
            atImportResolvers = (0, resolvers_1.createCSSResolvers)(config);
            resolvers_1.configToAtImportResolvers.set(config, atImportResolvers);
        }
        // 2. pre-processors: sass etc.
        if (isPreProcessor(lang)) {
            const preProcessor = preProcessors[lang];
            let opts = (preprocessorOptions && preprocessorOptions[lang]) || {};
            // support @import from node dependencies by default
            switch (lang) {
                case "scss" /* PreprocessLang.scss */:
                case "sass" /* PreprocessLang.sass */:
                    opts = Object.assign({ includePaths: ['node_modules'], alias: config.resolve.alias }, opts);
                    break;
                case "less" /* PreprocessLang.less */:
                case "styl" /* PreprocessLang.styl */:
                case "stylus" /* PreprocessLang.stylus */:
                    opts = Object.assign({ paths: ['node_modules'], alias: config.resolve.alias }, opts);
            }
            // important: set this for relative import resolving
            opts.filename = (0, utils_1.cleanUrl)(id);
            opts.enableSourcemap = devSourcemap !== null && devSourcemap !== void 0 ? devSourcemap : false;
            const preprocessResult = yield preProcessor(code, config.root, opts, atImportResolvers);
            if (preprocessResult.error) {
                throw preprocessResult.error;
            }
            code = preprocessResult.code;
            preprocessorMap = combineSourcemapsIfExists(opts.filename, preprocessResult.map, preprocessResult.additionalMap);
            if (preprocessResult.deps) {
                preprocessResult.deps.forEach((dep) => {
                    // sometimes sass registers the file itself as a dep
                    if ((0, vite_1.normalizePath)(dep) !== (0, vite_1.normalizePath)(opts.filename)) {
                        deps.add(dep);
                    }
                });
            }
        }
        // 3. postcss
        const postcssOptions = (postcssConfig && postcssConfig.options) || {};
        // for sugarss change parser
        if (lang === 'sss') {
            postcssOptions.parser = (0, resolvers_1.loadPreprocessor)("sugarss" /* PostCssDialectLang.sss */, config.root);
        }
        const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
        if (needInlineImport) {
            postcssPlugins.unshift((yield Promise.resolve().then(() => __importStar(require('postcss-import')))).default({
                resolve(id, basedir) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const publicFile = (0, asset_1.checkPublicFile)(id, config);
                        if (publicFile) {
                            return publicFile;
                        }
                        const resolved = yield atImportResolvers.css(id, node_path_1.default.join(basedir, '*'));
                        if (resolved) {
                            return node_path_1.default.resolve(resolved);
                        }
                        return id;
                    });
                },
                // @ts-ignore
                nameLayer(index) {
                    return `vite--anon-layer-${(0, helper_1.getHash)(id)}-${index}`;
                },
            }));
        }
        if (urlReplacer) {
            postcssPlugins.push((0, url_1.UrlRewritePostcssPlugin)({
                replacer: urlReplacer,
                logger: config.logger,
            }));
        }
        if (isModule) {
            postcssPlugins.unshift((yield Promise.resolve().then(() => __importStar(require('postcss-modules')))).default(Object.assign(Object.assign({}, modulesOptions), { localsConvention: modulesOptions === null || modulesOptions === void 0 ? void 0 : modulesOptions.localsConvention, getJSON(cssFileName, _modules, outputFileName) {
                    modules = _modules;
                    if (modulesOptions && typeof modulesOptions.getJSON === 'function') {
                        modulesOptions.getJSON(cssFileName, _modules, outputFileName);
                    }
                },
                resolve(id, importer) {
                    return __awaiter(this, void 0, void 0, function* () {
                        for (const key of (0, resolvers_1.getCssResolversKeys)(atImportResolvers)) {
                            const resolved = yield atImportResolvers[key](id, importer);
                            if (resolved) {
                                return node_path_1.default.resolve(resolved);
                            }
                        }
                        return id;
                    });
                } })));
        }
        postcssPlugins.push((yield Promise.resolve().then(() => __importStar(require('postcss-css-variables')))).default({}));
        if (!postcssPlugins.length) {
            return {
                code,
                map: preprocessorMap,
            };
        }
        let postcssResult;
        try {
            const source = (0, utils_1.removeDirectQuery)(id);
            // postcss is an unbundled dep and should be lazy imported
            postcssResult = yield (yield Promise.resolve().then(() => __importStar(require('postcss'))))
                .default(postcssPlugins)
                .process(code, Object.assign(Object.assign(Object.assign({}, postcssOptions), { to: source, from: source }), (devSourcemap
                ? {
                    map: {
                        inline: false,
                        annotation: false,
                        // postcss may return virtual files
                        // we cannot obtain content of them, so this needs to be enabled
                        sourcesContent: true,
                        // when "prev: preprocessorMap", the result map may include duplicate filename in `postcssResult.map.sources`
                        // prev: preprocessorMap,
                    },
                }
                : {})));
            // record CSS dependencies from @imports
            for (const message of postcssResult.messages) {
                if (message.type === 'dependency') {
                    deps.add((0, vite_1.normalizePath)(message.file));
                }
                else if (message.type === 'dir-dependency') {
                    // https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#3-dependencies
                    const { dir, glob: globPattern = '**' } = message;
                    const pattern = fast_glob_1.default.escapePath((0, vite_1.normalizePath)(node_path_1.default.resolve(node_path_1.default.dirname(id), dir))) +
                        `/` +
                        globPattern;
                    const files = fast_glob_1.default.sync(pattern, {
                        ignore: ['**/node_modules/**'],
                    });
                    for (let i = 0; i < files.length; i++) {
                        deps.add(files[i]);
                    }
                }
                else if (message.type === 'warning') {
                    let msg = `[taro:vite-style] ${message.text}`;
                    if (message.line && message.column) {
                        msg += `\n${(0, utils_1.generateCodeFrame)(code, {
                            line: message.line,
                            column: message.column,
                        })}`;
                    }
                    config.logger.warn(helper_1.chalk.yellow(msg));
                }
            }
        }
        catch (e) {
            e.message = `[postcss] ${e.message}`;
            e.code = code;
            e.loc = {
                column: e.column,
                line: e.line,
            };
            throw e;
        }
        if (!devSourcemap) {
            return {
                ast: postcssResult,
                code: postcssResult.css,
                map: { mappings: '' },
                modules,
                deps,
            };
        }
        const rawPostcssMap = postcssResult.map.toJSON();
        const postcssMap = yield formatPostcssSourceMap(
        // version property of rawPostcssMap is declared as string
        // but actually it is a number
        rawPostcssMap, (0, utils_1.cleanUrl)(id));
        return {
            ast: postcssResult,
            code: postcssResult.css,
            map: combineSourcemapsIfExists((0, utils_1.cleanUrl)(id), postcssMap, preprocessorMap),
            modules,
            deps,
        };
    });
}
exports.compileCSS = compileCSS;
function formatPostcssSourceMap(rawMap, file) {
    return __awaiter(this, void 0, void 0, function* () {
        const inputFileDir = node_path_1.default.dirname(file);
        const sources = rawMap.sources.map((source) => {
            const cleanSource = (0, utils_1.cleanUrl)(decodeURIComponent(source));
            // postcss returns virtual files
            if (/^<.+>$/.test(cleanSource)) {
                return `\0${cleanSource}`;
            }
            return (0, vite_1.normalizePath)(node_path_1.default.resolve(inputFileDir, cleanSource));
        });
        return {
            file,
            mappings: rawMap.mappings,
            names: rawMap.names,
            sources,
            sourcesContent: rawMap.sourcesContent,
            version: rawMap.version,
        };
    });
}
function combineSourcemapsIfExists(filename, map1, map2) {
    return map1 && map2
        ? (0, utils_1.combineSourcemaps)(filename, [
            // type of version property of ExistingRawSourceMap is number
            // but it is always 3
            map1,
            map2,
        ])
        : map1;
}
function isPreProcessor(lang) {
    return lang && lang in preProcessors;
}
function getCssDialect(lang) {
    return lang === 'sss' ? 'sss' : 'css';
}
//# sourceMappingURL=compile.js.map