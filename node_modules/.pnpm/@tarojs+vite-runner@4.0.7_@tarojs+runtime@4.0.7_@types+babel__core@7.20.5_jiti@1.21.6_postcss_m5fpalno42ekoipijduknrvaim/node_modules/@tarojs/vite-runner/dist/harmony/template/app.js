"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Parser_setReconciler, _Parser_setReconcilerPost;
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const shared_1 = require("@tarojs/shared");
const utils_1 = require("../../utils");
const entry_1 = require("../entry");
const page_1 = require("../page");
const base_1 = __importDefault(require("./base"));
class Parser extends base_1.default {
    constructor(appPath, appConfig, buildConfig, loaderMeta) {
        super();
        this.appPath = appPath;
        this.appConfig = appConfig;
        this.buildConfig = buildConfig;
        this.loaderMeta = loaderMeta;
        _Parser_setReconciler.set(this, '');
        _Parser_setReconcilerPost.set(this, '');
        this.init();
    }
    init() {
        const runtimePath = Array.isArray(this.buildConfig.runtimePath) ? this.buildConfig.runtimePath : [this.buildConfig.runtimePath];
        __classPrivateFieldSet(this, _Parser_setReconciler, runtimePath.reduce((res, item) => {
            if (item && /^post:/.test(item)) {
                __classPrivateFieldSet(this, _Parser_setReconcilerPost, __classPrivateFieldGet(this, _Parser_setReconcilerPost, "f") + `import '${item.replace(/^post:/, '')}'\n`, "f");
                return res;
            }
            else {
                return res + `import '${item}'\n`;
            }
        }, '') || '', "f");
    }
    getInitPxTransform() {
        return super.getInitPxTransform(this.buildConfig);
    }
    get instantiateApp() {
        const { modifyInstantiate } = this.loaderMeta;
        const { pages = [], entryPagePath = pages[0], tabBar } = this.appConfig;
        let entryPath = entryPagePath;
        const tabbarList = (tabBar === null || tabBar === void 0 ? void 0 : tabBar.list) || [];
        const tabbarIndex = tabbarList.findIndex(item => item.pagePath === entryPagePath);
        if (tabbarIndex >= 0) {
            entryPath = page_1.TARO_TABBAR_PAGE_PATH;
        }
        let instantiateApp = `export default class EntryAbility extends UIAbility {
  app?: AppInstance

  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
    AppStorage.setOrCreate('__TARO_ENTRY_PAGE_PATH', '${entryPagePath}')
    AppStorage.setOrCreate('__TARO_PAGE_STACK', [])
    // 引入
    initHarmonyElement()
    this.app = createComponent()
    callFn(this.app?.onLaunch, this, ObjectAssign(want, launchParam))
  }

  onDestroy() {}

  onWindowStageCreate(stage: ohWindow.WindowStage) {
    context.resolver(this.context)

    this.context.getApplicationContext().on('environment', {
      onConfigurationUpdated(config) {
        AppStorage.setOrCreate('__TARO_APP_CONFIG', config)
      },
      onMemoryLevel(level) {
        hooks.call('getMemoryLevel', { level })
      }
    })

    stage.loadContent('${entryPath}', (err, data) => {
      const windowClass = stage.getMainWindowSync()
      Current.uiContext = windowClass.getUIContext()
      windowClass.setWindowLayoutFullScreen(true)

      if (err.code) {
        return callFn(this.app?.onError, this, err)
      }
    })
  }

  onForeground() {
    callFn(this.app?.onShow, this)
  }

  onBackground() {
    callFn(this.app?.onHide, this)
  }

  onMemoryLevel(level: AbilityConstant.MemoryLevel) {
    let levelRes: number

    switch (level) {
      case AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE:
        levelRes = 5
        break
      case AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW:
        levelRes = 10
        break
      case AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL:
        levelRes = 15
        break
    }

    if (levelRes) {
      hooks.call('getMemoryLevel', { level: levelRes })
    }
  }
}
`;
        if ((0, shared_1.isFunction)(modifyInstantiate)) {
            instantiateApp = modifyInstantiate.call(this, instantiateApp, 'app');
        }
        return instantiateApp;
    }
    parse(rawId, name = 'TaroPage', resolve) {
        const { modifyResolveId } = this.loaderMeta;
        const code = this.transArr2Str([
            'import type Want from "@ohos.app.ability.Want"',
            'import type ohWindow from "@ohos.window"',
            'import type { AppInstance } from "@tarojs/runtime"',
            '',
            __classPrivateFieldGet(this, _Parser_setReconciler, "f"),
            'import UIAbility from "@ohos.app.ability.UIAbility"',
            'import AbilityConstant from "@ohos.app.ability.AbilityConstant"',
            'import { callFn, context, Current, ObjectAssign, TaroAny, window } from "@tarojs/runtime"',
            'import { initHarmonyElement, hooks } from "@tarojs/runtime"',
            `import createComponent, { config } from "./${node_path_1.default.basename(rawId, node_path_1.default.extname(rawId))}${entry_1.TARO_COMP_SUFFIX}"`,
            __classPrivateFieldGet(this, _Parser_setReconcilerPost, "f"),
            '',
            'window.__taroAppConfig = config',
            this.instantiateApp,
        ]);
        const { outputRoot = 'dist', sourceRoot = 'src' } = this.buildConfig;
        return (0, utils_1.resolveAbsoluteRequire)({
            name,
            importer: rawId,
            code,
            outputRoot,
            targetRoot: node_path_1.default.resolve(this.appPath, sourceRoot),
            resolve,
            modifyResolveId,
        });
    }
    parseEntry(rawId, config = {}) {
        const { creator, creatorLocation, frameworkArgs, importFrameworkStatement, modifyEntryFile } = this.loaderMeta;
        const createApp = `${creator}(component, ${frameworkArgs})`;
        const rawCode = this.transArr2Str([
            'import { initPxTransform } from "@tarojs/taro"',
            `import { ${creator} } from "${creatorLocation}"`,
            `import component from "${(0, utils_1.escapePath)(rawId)}"`,
            importFrameworkStatement,
            `export const config = ${this.prettyPrintJson(config)}`,
            this.getInitPxTransform(),
            `export default () => ${createApp}`,
        ]);
        return (0, shared_1.isFunction)(modifyEntryFile) ? modifyEntryFile.call(this, 'app', rawId, rawCode, config) : rawCode;
    }
}
_Parser_setReconciler = new WeakMap(), _Parser_setReconcilerPost = new WeakMap();
exports.default = Parser;
//# sourceMappingURL=app.js.map