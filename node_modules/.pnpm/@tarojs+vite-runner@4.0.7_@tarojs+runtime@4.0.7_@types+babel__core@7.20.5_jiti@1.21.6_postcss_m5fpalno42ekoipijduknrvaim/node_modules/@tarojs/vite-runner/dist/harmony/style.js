"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stylePostPlugin = exports.stylePlugin = void 0;
const node_path_1 = __importDefault(require("node:path"));
const core_1 = require("@babel/core");
const pluginutils_1 = require("@rollup/pluginutils");
const helper_1 = require("@tarojs/helper");
const parse_css_to_stylesheet_1 = require("@tarojs/parse-css-to-stylesheet");
const lodash_1 = require("lodash");
const magic_string_1 = __importDefault(require("magic-string"));
const stylelint_1 = __importDefault(require("stylelint"));
const utils_1 = require("../utils");
const asset_1 = require("./asset");
const postcss_1 = require("./postcss");
const constants_1 = require("./postcss/constants");
const utils_2 = require("./postcss/utils");
const STYLE_SUFFIX = '.xss';
const STYLE_SUFFIX_RE = new RegExp(`\\${STYLE_SUFFIX}(\\?\\S+)?$`);
// const cssBundleName = 'style.css'
const isStyleRequest = (request) => constants_1.CSS_LANGS_RE.test(request.replace(STYLE_SUFFIX_RE, ''));
const cssModulesCache = new WeakMap();
const cssMapCache = new WeakMap();
const removedPureCssFilesCache = new WeakMap();
function getCssIdSets(raw, id, sourceDir) {
    const cssIdSet = new Set();
    (0, core_1.transformSync)(raw, {
        filename: id,
        parserOpts: {
            plugins: [
                'jsx',
                'typescript',
            ],
        },
        plugins: [
            [
                function importPlugin() {
                    return {
                        name: 'taro-import-plugin',
                        visitor: {
                            ImportDeclaration(ats) {
                                const rawId = ats.node.source.value;
                                const resolveId = (0, helper_1.resolveSync)(rawId, {
                                    basedir: node_path_1.default.dirname(id) || sourceDir,
                                    extensions: helper_1.CSS_EXT,
                                });
                                if (resolveId && constants_1.CSS_LANGS_RE.test(rawId)) {
                                    // Note: 预加载依赖的 CSS 文件
                                    const cssId = (0, utils_1.appendVirtualModulePrefix)(resolveId + STYLE_SUFFIX);
                                    cssIdSet.add(cssId);
                                }
                                // const node = path.node
                                // if (t.isIdentifier(node) && node.loc) {
                                //   await that.load.add(node.name)
                                // }
                            }
                        },
                    };
                }
            ]
        ],
    });
    return cssIdSet;
}
function stylePlugin(viteCompilerContext) {
    return __awaiter(this, void 0, void 0, function* () {
        let moduleCache;
        let cssCache;
        let globalCssCache;
        let viteConfig;
        let resolveUrl;
        return {
            name: 'taro:vite-style',
            enforce: 'pre',
            configResolved(config) {
                resolveUrl = config.createResolver({
                    preferRelative: true,
                    tryIndex: false,
                    extensions: [],
                });
                viteConfig = config;
            },
            buildStart() {
                // Ensure a new cache for every build (i.e. rebuilding in watch mode)
                if (cssModulesCache.has(viteConfig)) {
                    moduleCache = cssModulesCache.get(viteConfig);
                }
                else {
                    moduleCache = new Map();
                    cssModulesCache.set(viteConfig, moduleCache);
                }
                if (cssMapCache.has(viteConfig)) {
                    cssCache = cssMapCache.get(viteConfig);
                }
                else {
                    cssCache = new Map();
                    cssMapCache.set(viteConfig, cssCache);
                }
                removedPureCssFilesCache.set(viteConfig, new Map());
            },
            resolveId(source, importer) {
                if (constants_1.CSS_LANGS_RE.test(source)) {
                    const sourceDir = importer ? node_path_1.default.dirname(importer) : viteCompilerContext.sourceDir;
                    const suffix = source.includes('?')
                        ? source.slice(source.lastIndexOf('?'))
                        : '';
                    const virtualId = (0, helper_1.resolveSync)(source.replace(suffix, ''), {
                        basedir: sourceDir,
                        extensions: helper_1.CSS_EXT,
                    });
                    if (virtualId) {
                        return (0, utils_1.appendVirtualModulePrefix)(virtualId + STYLE_SUFFIX + suffix);
                    }
                }
                return null;
            },
            load(id) {
                if (isStyleRequest(id)) {
                    const rawId = (0, utils_1.stripVirtualModulePrefix)(id).replace(STYLE_SUFFIX_RE, '');
                    this.addWatchFile(rawId);
                    return helper_1.fs.readFileSync(rawId, 'utf-8');
                }
            },
            transform(raw, id) {
                return __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c;
                    if (viteCompilerContext.loaderMeta.enableParseJSXStyle && !viteCompilerContext.loaderMeta.parseJSXStyleMapCache) {
                        viteCompilerContext.loaderMeta.parseJSXStyleMapCache = cssMapCache;
                    }
                    if (constants_1.commonjsProxyRE.test(id) ||
                        constants_1.SPECIAL_QUERY_RE.test(id) ||
                        constants_1.loadParseImportRE.test(id))
                        return;
                    // 如果是node_modules的文件，判断是否js\jsx\tsx
                    if (helper_1.REG_NODE_MODULES.test(id)) {
                        if (helper_1.REG_JS.test(id) || helper_1.REG_SCRIPTS.test(id)) {
                            // 读写内容，判断raw是否含有createElement 或者 jsx-runtime
                            if (!(raw.includes('createElement') || raw.includes('jsx-runtime'))) {
                                // 普通js文件，不走样式处理
                                return;
                            }
                        }
                    }
                    // Note: 新版本 rust 插件不需要修改 JSX 代码
                    if (!isStyleRequest(id) && viteCompilerContext.loaderMeta.enableParseJSXStyle)
                        return;
                    if (!isStyleRequest(id)) {
                        if (!helper_1.REG_SCRIPTS.test(id))
                            return;
                        try {
                            const isEntry = viteCompilerContext.taroConfig.entry.app.includes(id);
                            if (!isEntry && !globalCssCache) {
                                const entryPath = viteCompilerContext.taroConfig.entry.app;
                                if (typeof entryPath === 'string') {
                                    yield this.load({
                                        id: entryPath,
                                        resolveDependencies: true,
                                    });
                                }
                                else {
                                    yield Promise.all(entryPath.map((entry) => __awaiter(this, void 0, void 0, function* () {
                                        yield this.load({
                                            id: entry,
                                            resolveDependencies: true,
                                        });
                                    })));
                                }
                            }
                            const cssIdSet = getCssIdSets(raw, id, viteCompilerContext.sourceDir);
                            if (isEntry) {
                                globalCssCache = cssIdSet;
                            }
                            else {
                                globalCssCache.forEach((cssId) => {
                                    cssIdSet.add(cssId);
                                });
                            }
                            // Note: 确保 CSS 文件已经加载
                            yield Promise.all(Array.from(cssIdSet).map((cssId) => __awaiter(this, void 0, void 0, function* () {
                                yield this.load({
                                    id: cssId,
                                    resolveDependencies: true,
                                });
                            })));
                            if (cssIdSet.size) {
                                const cssRawArr = Array.from(cssIdSet).map((cssId) => {
                                    const rawId = (0, utils_1.stripVirtualModulePrefix)(cssId).replace(STYLE_SUFFIX_RE, '').replace(constants_1.usedRE, '');
                                    return cssCache.get(rawId) || '';
                                });
                                const { code: raw_code } = (0, parse_css_to_stylesheet_1.parse)(raw, cssRawArr, {
                                    platformString: 'Harmony'
                                });
                                const s = new magic_string_1.default(raw_code);
                                return {
                                    code: s.toString(),
                                    map: s.generateMap({ hires: true }),
                                };
                            }
                        }
                        catch (error) {
                            console.error(error);
                        }
                        return;
                    }
                    id = (0, utils_1.stripVirtualModulePrefix)(id).replace(STYLE_SUFFIX, '');
                    const urlReplacer = (url, importer) => __awaiter(this, void 0, void 0, function* () {
                        if ((0, asset_1.checkPublicFile)(url, viteConfig)) {
                            return (0, asset_1.publicFileToBuiltUrl)(url, viteConfig);
                        }
                        const resolved = yield resolveUrl(url, importer);
                        if (resolved) {
                            return (0, asset_1.fileToUrl)(resolved, viteConfig, this, viteCompilerContext);
                        }
                        viteConfig.logger.warnOnce(`\n${url} referenced in ${id} didn't resolve at build time, it will remain unchanged to be resolved at runtime`);
                        return url;
                    });
                    const { taroConfig } = viteCompilerContext;
                    const isGlobalModule = ((_c = (_b = (_a = taroConfig === null || taroConfig === void 0 ? void 0 : taroConfig.postcss) === null || _a === void 0 ? void 0 : _a.cssModules) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.namingPattern) === 'global';
                    const { code: css, modules, deps, map, } = yield (0, postcss_1.compileCSS)(id, raw, viteConfig, urlReplacer, isGlobalModule);
                    // if (!cssCache.has(id)) {
                    cssCache.set(id, css);
                    // }
                    // 校验css
                    validateStylelint(id, raw);
                    const rawId = id.replace(STYLE_SUFFIX_RE, '').replace(constants_1.usedRE, '');
                    if (modules && !moduleCache.has(rawId)) {
                        moduleCache.set(rawId, modules);
                    }
                    // track deps for build watch mode
                    if (viteConfig.build.watch && deps) {
                        for (const file of deps) {
                            this.addWatchFile(file);
                        }
                    }
                    return {
                        code: css,
                        map,
                    };
                });
            }
        };
    });
}
exports.stylePlugin = stylePlugin;
function stylePostPlugin(_viteCompilerContext) {
    return __awaiter(this, void 0, void 0, function* () {
        // styles initialization in buildStart causes a styling loss in watch
        const styles = new Map();
        let pureCssChunks;
        // Note: ETS 模式不需要注入 CSS 文件
        // when there are multiple rollup outputs and extracting CSS, only emit once,
        // since output formats have no effect on the generated CSS.
        // let outputToExtractedCSSMap: Map<NormalizedOutputOptions, string>
        // let hasEmitted = false
        // const config = await resolveConfig({}, 'build')
        // const rollupOptionsOutput = config.build.rollupOptions.output
        let viteConfig;
        // const assetFileNames = (
        //   Array.isArray(rollupOptionsOutput)
        //     ? rollupOptionsOutput[0]
        //     : rollupOptionsOutput
        // )?.assetFileNames
        // const getCssAssetDirname = (config: ResolvedConfig, cssAssetName: string) => {
        //   if (!assetFileNames) {
        //     return config.build.assetsDir
        //   } else if (typeof assetFileNames === 'string') {
        //     return path.dirname(assetFileNames)
        //   } else {
        //     return path.dirname(
        //       assetFileNames({
        //         name: cssAssetName,
        //         type: 'asset',
        //         source: '/* vite internal call, ignore */',
        //       }),
        //     )
        //   }
        // }
        return {
            name: 'taro:vite-style-post',
            enforce: 'post',
            configResolved(config) {
                viteConfig = config;
            },
            buildStart() {
                // Ensure new caches for every build (i.e. rebuilding in watch mode)
                pureCssChunks = new Set();
                // outputToExtractedCSSMap = new Map<NormalizedOutputOptions, string>()
                // hasEmitted = false
            },
            transform(raw, id) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!isStyleRequest(id) ||
                        constants_1.commonjsProxyRE.test(id) ||
                        constants_1.SPECIAL_QUERY_RE.test(id)) {
                        return;
                    }
                    id = (0, utils_1.stripVirtualModulePrefix)(id).replace(STYLE_SUFFIX, '');
                    const css = (0, utils_2.stripBomTag)(raw);
                    const inlined = constants_1.inlineRE.test(id);
                    const rawId = (0, utils_1.stripVirtualModulePrefix)(id).replace(STYLE_SUFFIX_RE, '').replace(constants_1.usedRE, '');
                    const modules = cssModulesCache.get(viteConfig).get(rawId);
                    // `foo.module.css` => modulesCode
                    // `foo.module.css?inline` => cssContent
                    const modulesCode = modules &&
                        !inlined &&
                        (0, pluginutils_1.dataToEsm)(modules, { namedExports: true, preferConst: true });
                    // build CSS handling ----------------------------------------------------
                    // record css
                    // cache css compile result to map
                    // and then use the cache replace inline-style-flag when `generateBundle` in vite:build-html plugin
                    const inlineCSS = constants_1.inlineCSSRE.test(id);
                    const isHTMLProxy = constants_1.htmlProxyRE.test(id);
                    if (inlineCSS && isHTMLProxy) {
                        return `export default ''`;
                    }
                    if (!inlined) {
                        styles.set(id, css);
                    }
                    let code;
                    if (constants_1.usedRE.test(id)) {
                        if (modulesCode) {
                            code = modulesCode;
                        }
                        else {
                            code = `export default ${JSON.stringify(css)}`;
                        }
                    }
                    else {
                        // if moduleCode exists return it **even if** it does not have `?used`
                        // this will disable tree-shake to work with `import './foo.module.css'` but this usually does not happen
                        // this is a limitation of the current approach by `?used` to make tree-shake work
                        // See #8936 for more details
                        code = modulesCode || `export default ''`;
                    }
                    return {
                        code,
                        map: { mappings: '' },
                        // avoid the css module from being tree-shaken so that we can retrieve
                        // it in renderChunk()
                        moduleSideEffects: false,
                        // moduleSideEffects: inlined ? false : 'no-treeshake',
                    };
                });
            },
            renderChunk(code, chunk, opts) {
                return __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    let chunkCSS = '';
                    let isPureCssChunk = true;
                    const ids = Object.keys(chunk.modules);
                    for (let id of ids) {
                        id = (0, utils_1.stripVirtualModulePrefix)(id).replace(STYLE_SUFFIX_RE, '');
                        if (styles.has(id)) {
                            chunkCSS += styles.get(id);
                            // a css module contains JS, so it makes this not a pure css chunk
                            if (constants_1.cssModuleRE.test(id)) {
                                isPureCssChunk = false;
                            }
                        }
                        else {
                            // if the module does not have a style, then it's not a pure css chunk.
                            // this is true because in the `transform` hook above, only modules
                            // that are css gets added to the `styles` map.
                            isPureCssChunk = false;
                        }
                    }
                    if (!chunkCSS) {
                        return null;
                    }
                    // const publicAssetUrlMap = publicAssetUrlCache.get(viteConfig)!
                    // resolve asset URL placeholders to their built file URLs
                    // const resolveAssetUrlsInCss = (
                    //   chunkCSS: string,
                    //   cssAssetName: string,
                    // ) => {
                    //   const cssAssetDirname = getCssAssetDirname(viteConfig, cssAssetName)
                    //   const toRelative = (filename: string) => {
                    //     // relative base + extracted CSS
                    //     const relativePath = path.posix.relative(cssAssetDirname!, filename)
                    //     return relativePath.startsWith('.')
                    //       ? relativePath
                    //       : './' + relativePath
                    //   }
                    //   // replace asset url references with resolved url.
                    //   chunkCSS = chunkCSS.replace(assetUrlRE, (_, fileHash, postfix = '') => {
                    //     const filename = this.getFileName(fileHash) + postfix
                    //     return toOutputFilePathInCss(
                    //       filename,
                    //       'asset',
                    //       cssAssetName,
                    //       'css',
                    //       viteConfig,
                    //       toRelative,
                    //     )
                    //   })
                    //   // resolve public URL from CSS paths
                    //   const relativePathToPublicFromCSS = path.posix.relative(
                    //     cssAssetDirname!,
                    //     '',
                    //   )
                    //   chunkCSS = chunkCSS.replace(publicAssetUrlRE, (_, hash) => {
                    //     const publicUrl = publicAssetUrlMap.get(hash)!.slice(1)
                    //     return toOutputFilePathInCss(
                    //       publicUrl,
                    //       'public',
                    //       cssAssetName,
                    //       'css',
                    //       viteConfig,
                    //       () => `${relativePathToPublicFromCSS}/${publicUrl}`,
                    //     )
                    //   })
                    //   return chunkCSS
                    // }
                    // function ensureFileExt(name: string, ext: string) {
                    //   return normalizePath(
                    //     path.format({ ...path.parse(name), base: undefined, ext }),
                    //   )
                    // }
                    if (isPureCssChunk) {
                        // this is a shared CSS-only chunk that is empty.
                        pureCssChunks.add(chunk);
                    }
                    if (opts.format === 'es' || opts.format === 'cjs') {
                        // const cssAssetName = chunk.facadeModuleId
                        //   ? normalizePath(path.relative(viteConfig.root, chunk.facadeModuleId))
                        //   : chunk.name
                        // const lang = path.extname(cssAssetName).slice(1)
                        // const cssFileName = ensureFileExt(cssAssetName, '.css')
                        // chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName)
                        // chunkCSS = await finalizeCss(chunkCSS)
                        // emit corresponding css file
                        /** const referenceId = */
                        // this.emitFile({
                        //   name: path.basename(cssFileName),
                        //   type: 'asset',
                        //   source: chunkCSS,
                        // })
                        // TODO 考虑 CSS 中相关 asset 处理方案
                        // const originalName = isPreProcessor(lang) ? cssAssetName : cssFileName
                        // const isEntry = chunk.isEntry && isPureCssChunk
                        // generatedAssets
                        //   .get(viteConfig)!
                        //   .set(referenceId, { originalName, isEntry })
                        // chunk.viteMetadata!.importedCss.add(this.getFileName(referenceId))
                    }
                    else {
                        chunkCSS = yield (0, utils_2.finalizeCss)(chunkCSS);
                        let cssString = JSON.stringify(chunkCSS);
                        cssString =
                            ((_a = (0, asset_1.renderAssetUrlInJS)(this, viteConfig, chunk, opts, cssString)) === null || _a === void 0 ? void 0 : _a.toString()) || cssString;
                        const style = `__vite_style__`;
                        const injectCode = `var ${style} = document.createElement('style');` +
                            `${style}.textContent = ${cssString};` +
                            `document.head.appendChild(${style});`;
                        const wrapIdx = code.indexOf('System.register');
                        const insertMark = "'use strict';";
                        const insertIdx = code.indexOf(insertMark, wrapIdx);
                        const s = new magic_string_1.default(code);
                        s.appendLeft(insertIdx + insertMark.length, injectCode);
                        if (viteConfig.build.sourcemap) {
                            // resolve public URL from CSS paths, we need to use absolute paths
                            return {
                                code: s.toString(),
                                map: s.generateMap({ hires: true }),
                            };
                        }
                        else {
                            return { code: s.toString() };
                        }
                    }
                    return null;
                });
            },
            generateBundle(opts, bundle) {
                return __awaiter(this, void 0, void 0, function* () {
                    // @ts-expect-error asset emits are skipped in legacy bundle
                    if (opts.__vite_skip_asset_emit__) {
                        return;
                    }
                    // remove empty css chunks and their imports
                    if (pureCssChunks.size) {
                        // map each pure css chunk (rendered chunk) to it's corresponding bundle
                        // chunk. we check that by comparing the `moduleIds` as they have different
                        // filenames (rendered chunk has the !~{XXX}~ placeholder)
                        const pureCssChunkNames = [];
                        for (const pureCssChunk of pureCssChunks) {
                            for (const key in bundle) {
                                const bundleChunk = bundle[key];
                                if (bundleChunk.type === 'chunk' &&
                                    (0, lodash_1.isEqual)(bundleChunk.moduleIds, pureCssChunk.moduleIds)) {
                                    pureCssChunkNames.push(key);
                                    break;
                                }
                            }
                        }
                        const emptyChunkFiles = pureCssChunkNames
                            .map((file) => node_path_1.default.basename(file))
                            .join('|')
                            .replace(/\./g, '\\.');
                        const emptyChunkRE = new RegExp(opts.format === 'es'
                            ? `\\bimport\\s*["'][^"']*(?:${emptyChunkFiles})["'];\n?`
                            : `\\brequire\\(\\s*["'][^"']*(?:${emptyChunkFiles})["']\\);\n?`, 'g');
                        for (const file in bundle) {
                            const chunk = bundle[file];
                            if (chunk.type === 'chunk') {
                                // remove pure css chunk from other chunk's imports,
                                // and also register the emitted CSS files under the importer
                                // chunks instead.
                                chunk.imports = chunk.imports.filter((file) => {
                                    if (pureCssChunkNames.includes(file)) {
                                        return false;
                                    }
                                    return true;
                                });
                                chunk.code = chunk.code.replace(emptyChunkRE, 
                                // remove css import while preserving source map location
                                (m) => `/* empty css ${''.padEnd(m.length - 15)}*/`);
                            }
                        }
                        const removedPureCssFiles = removedPureCssFilesCache.get(viteConfig);
                        pureCssChunkNames.forEach((fileName) => {
                            removedPureCssFiles.set(fileName, bundle[fileName]);
                            delete bundle[fileName];
                        });
                    }
                    // let extractedCss = outputToExtractedCSSMap.get(opts as any)
                    // if (extractedCss && !hasEmitted) {
                    //   hasEmitted = true
                    //   extractedCss = await finalizeCss(extractedCss)
                    //   this.emitFile({
                    //     name: cssBundleName,
                    //     type: 'asset',
                    //     source: extractedCss,
                    //   })
                    // }
                });
            },
        };
    });
}
exports.stylePostPlugin = stylePostPlugin;
// 校验stylelint
function validateStylelint(id, code) {
    stylelint_1.default.lint({
        code,
        configBasedir: process.cwd()
    }).then(res => {
        if (res.errored) {
            // eslint-disable-next-line no-console
            // console.log(res.output)
        }
        else {
            res.results.forEach(res => {
                if (res.warnings.length) {
                    // eslint-disable-next-line no-console
                    console.log('\n', helper_1.chalk.cyan('Taro多端样式检测:'), helper_1.chalk.gray(id));
                }
                res.warnings.forEach(warning => {
                    // eslint-disable-next-line no-console
                    console.log(' |', helper_1.chalk.gray(`${node_path_1.default.basename(id)}:[${warning.line}:${warning.column}]`), highlightQuotes(warning.text));
                });
            });
        }
    }).catch(_ => {
        // 没有stylelint配置文件
    });
}
function highlightQuotes(inputString) {
    // 使用正则表达式匹配双引号内容
    const regex = /"("?[^"]*?"?)"/g;
    // 使用 replace 方法将匹配到的双引号内容进行高亮
    const highlightedString = inputString.replace(regex, (_, group) => {
        return helper_1.chalk.yellow(`"${group}"`);
    });
    return highlightedString;
}
//# sourceMappingURL=style.js.map